## 1 Stop-And-Copy

Есть две кучи: from-space и to-space. Все объекты находятся в куче from-space. Когда начинается очистка, мы _останавливаем_ программу, перемещаем все живые объекты в to-space кучу, при этом упаковывая их рядышком. При перемещении ссылки на перекладываемые объекты должны поменяться, ну, мы делаем это прям во время перемещения. Затем очищаем from-space и кучи меняются местами.

Естественно есть минусы:
- Нужно в два раза больше памяти на эти две кучи
- Постоянно двигаем (копируем) абсолютно все объекты туда-сюда, даже когда это не необходимо
- Stop the world - буквально останавливаем исполнение программы, чтобы ничего не сломать в графе объектов.

Поэтому…

## 2 Mark-And-Sweep

Чтобы избежать постоянного копирования всех объектов, когда на самом деле мусора не так много, есть вот этот вот метод. Но он медленнее в ситуациях, когда накапливается много мусора.

Сначала делаем все то же самое для обнаружения мусора: начинаем из стека/статической памяти, и отслеживаем (trace) наши объектики. Но каждый раз когда находим живой объект, помечаем его флагом. Это фаза “marking”.

Затем, после завершения marking’а, наступает “sweep” фаза, когда мертвые мусорные непомеченные флагом объекты отпускаются из памяти.

Минусы:
- Все еще требует остановки программы 
- Так как мы не перемещаем объекты из кучи в кучу, то память становится фрагментированной и неудобной. То есть нет упаковочки кучи.

## 3 **Mark-And-Sweep Compact**

Отличается от Mark-And-Sweep только тем, что убирает фрагментацию памяти. Очев поэтому чуть дороже из-за копирований объектов.

## 4 Сборка мусора на поколениях

Итак, исходя из опыта предыдущих алгоритмов (stop-and-copy, mark-and-sweep), мы теперь знаем две вещи:
1. Большинство объектов в программе либо живут очень долго, либо очень недолго. Причем первых очень очень мало.
2. Существует очень мало связей между старыми и новыми объектами

Это называется слабой гипотезой о поколениях. На ней мы и будем строить новый алгоритм сборки мусора.

Эта гипотеза гласит, что вероятность смерти как функция от возраста снижается очень быстро. Значит, чем дольше прожил объект, тем выше вероятность того, что он будет жить и дальше. А новые объекты обычно живут крайне недолго.
![[Screenshot 2025-08-30 at 01.35.22.png]]

Значит, можем разделить объекты на младшее поколение (**young generation**) и старшее поколение (**old generation**). В соответствии с этим разделенеием, разделим еще и процессы сборки мусора на малую сборку (**minor GC**) и полную сборку (**full GC**).

**Minor GC** выполняются довольно часто и удаляют основную часть мертвых объектов (то что самое левое большое на графике).

**Full GC** выполняются, когда текущий объем используемой памяти в программе близок к концу.

Итак, для оптимизации и схемы хранения наших поколений, память кучи разделена на четыре области, в которые объекты летят в зависимости от своего возраста:
![[Screenshot 2025-08-30 at 01.41.20.png]]

#### **Young Generation**

Маладые зумерки. Сюда попадают все новорожденные объекты. И как в любом антиутопичном аниме, разделим это поколение на три части:

- Eden (Эдем) — область динамической памяти, в которой изначально создаются все объекты (`new Den4ik()` попадет именно сюда, даже если она долговечна). Многие прям тут и умирают, становясь мусором (всякие итераторы, например)

- Survivors space, который делится на S0 и S1. Сюда попадают объекты, пережившие “изгнание из Эдема”. Эти две области можно называть From Space и To Space, как в stop-and-copy. Объекты шароебятся из S0 в S1 и обратно на этапах сборки мусора, поэтому одна из областей всегда пустует.
#### **Old Generation (Tenured)**

Сюда попадают из To Space (S1), если прожили достаточно долго. Здесь эти объекты больше не будут трогать во время малой сборки, так как предполагается, что старые объекты проживут еще долго.

## Еще одна область памяти

Короче, ну нужно же где то еще хранить структуры для определений класса пон? И вот где нам хранить эти метаданные. Раньше это было в PermGen области динамической памяти, куда обычным объектам был запрещен вход, и были болячки OutOfMemoryError из-за неправильных предсказаний размера этой области. Ну и в Java 8 убрали эту область, и часть этой метаинфы осталась на heap’е, например [интернированные строки](https://www.baeldung.com/string/intern) (стринг пул все дела), а все остальное выносится в область Metaspace, в native memory.

## И еще немного про Minor/Full/Major GC

#### **Minor GC**

В ходе несовершеннолетней сборки система пытается очистить только области с объектами молодого поколения - Eden и Survivor. Начинается когда Eden становится полностью заполнен.

1. Все живые молодые объекты, найденные во время этапа обнаружения, которые пережили достаточное количество предыдущих сборов мусора, перемещаются дальше по возрасту: из Eden в Survivor, из Survivor в Tenured (Old Generation).

2. После этого Eden и только что очищенная область в Survivor могут быть очищены и использованы заново, так как в них остался только мусор.

#### **Major GC**

В ходе major сбора система пытается очистить области со старым поколением.

#### **Full GC**

Если Minor GC не может перевести объект в хранилище из-за недостатка пространства, то запускается Full GC.

Этот сбор затрагивает все области - и со старым, и с новым поколением.

Происходят нечасто, но занимают много времени.
## **Кеширование**

Hibernate поддерживает два уровня кэширования для оптимизации производительности:
### 1. Первый уровень кеширования (L1 Cache или Session Cache)

##### **Как работает L1 Cache?**

- Когда мы загружаем сущность с помощью `find()`, `getReference()` или HQL-запроса, Hibernate сначала **проверяет кэш первого уровня**. 
- **Если объект уже есть в кэше**, Hibernate возвращает его из памяти, не отправляя SQL-запрос. 
- **Если объекта нет**, Hibernate загружает его из базы данных и добавляет в кэш.

##### Особенности

- Работает на уровне `Session`.
- Включён по умолчанию.
- Позволяет избежать повторных запросов к БД в рамках одной сессии.
- Если сущность уже загружена в `Session`, повторный `find()` или `getReference()` получит объект из кеша.
- L1-Кеш очищается при закрытии `Session`
- List<> не кешируются
- Хранится в оперативной памяти в рамках текущей `Session` как **HashMap**, где ключ — это `id`, а значение — сам объект

Наглядный пример:
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

// Первый запрос — объект загружается из БД
User user1 = session.find(User.class, 1L);
System.out.println(user1.getName());  // SQL-запрос выполняется

// Второй запрос того же объекта — берётся из кэша
User user2 = session.find(User.class, 1L);
System.out.println(user2.getName());  // SQL-запрос НЕ выполняется

tx.commit();
session.close();  // Кэш очищается
```

##### Какие методы используют L1-кеш?

**Используют кэш (не делают повторный SQL-запрос):**

- `session.find(Class, id)`
- `session.getReference(Class, id)`
- `session.get(Class, id)` (устаревший)

**Не используют кэш (всегда делают SQL-запрос):**

- `session.createQuery("FROM User WHERE id = :id")`
- `session.createNativeQuery("SELECT * FROM users WHERE id = :id")`

### 2. Второй уровень кеширования (L2 Cache)

Второй уровень кэширования (L2 Cache) — это механизм Hibernate, который **кэширует данные на уровне `SessionFactory`** и **разделяет кэш между разными сессиями**. Это позволяет значительно снизить нагрузку на базу данных, так как одни и те же объекты могут переиспользоваться в разных `Session`.

##### **Как работает L2 Cache?**

1. **При первом запросе** Hibernate ищет объект в **L1 Cache (Session Cache)**
2. Если **в L1 Cache нет**, проверяется **L2 Cache**
3. Если **в L2 Cache тоже нет**, выполняется **SQL-запрос в БД**
4. После загрузки объекта он **сохраняется в L1 Cache и (опционально) в L2 Cache**
5. При следующих запросах **объект берётся из L2 Cache** без SQL-запроса

**Главное отличие от L1 Cache** — L2 Cache живёт **дольше одной `Session`** и доступен для всех сессий внутри `SessionFactory`.

##### Особенности

- Доступен **для всех сессий** в рамках `SessionFactory` (в отличие от L1-кэша, который работает только в одной `Session`).
- **Не включён по умолчанию** — его нужно явно активировать и выбрать кэш-провайдер (`Ehcache`, `Redis`, `Infinispan` и т. д.).
- Может хранить данные в **оперативной памяти, файлах или распределённых системах** (например, Redis).
- Использует стратегии кэширования (`READ_ONLY`, `NONSTRICT_READ_WRITE`, `READ_WRITE`, `TRANSACTIONAL`) для управления согласованностью данных.
- **Снижение нагрузки на базу данных** — если объект есть в L2-кэше, SQL-запрос к БД не выполняется.
- **Может быть неактуальным (stale data)**, если данные в БД изменились, но кэш не обновился.
- **Можно настраивать по-разному для разных сущностей**, указывая `@Cacheable` и стратегию в `@Cache`.
- **Не кеширует коллекции по умолчанию** — для этого нужно вручную включить `@Cache` на уровне коллекций.
- **Может работать медленнее, чем L1-кэш**, так как хранится за пределами `Session` и требует синхронизации.
- **Подходит для редко изменяемых данных** (например, справочники, настройки), но не для часто обновляемых записей.

## **Lazy Loading и Eager Loading**

- Для отношений типа **OneToMany**, **ManyToMany** по умолчанию используется **Lazy Loading**.
- Для **ManyToOne** или **OneToOne** по умолчанию используется **Eager Loading**.

Если вы хотите изменить это поведение, можно указать **fetch type** явно:
```java
@OneToMany(fetch = FetchType.LAZY)
private Set<Order> orders;
```
```java
@OneToMany(fetch = FetchType.LAZY)
private Set<Order> orders;

```
### 1. Lazy Loading

**Lazy Loading** (ленивая загрузка) — это стратегия загрузки данных, при которой связанные сущности (например, коллекции или объекты) не загружаются сразу при загрузке основной сущности, а только тогда, когда к ним осуществляется доступ. Это позволяет уменьшить количество загружаемых данных и сэкономить ресурсы, загружая их по мере необходимости.

Пример:
```java
Author author = session.get(Author.class, 1); // Автор загружается, книги не загружаются
List<Book> books = author.getBooks(); // Книги загружаются только при обращении к ним
```

#### Как работает Lazy Loading?

Когда используется **Lazy Loading**, Hibernate не загружает связанные сущности сразу. Вместо этого, Hibernate создаёт **прокси-объекты** (что-то типа, `ProxyBook`), которые только представляют данные и не содержат их до первого обращения.

- Когда вы вызываете `getBooks()`, вы фактически получаете **прокси-объекты**. Эти прокси не содержат реальных данных и лишь указывают на то, что данные нужно подгрузить из базы данных при первом обращении.
- Как только вы обращаетесь к конкретному полю прокси-объекта (например, к названию книги через `book.getTitle()`), Hibernate делает запрос к базе данных для загрузки данных.

#### Проблемы, связанные с Lazy Loading:

- **Проблемы с производительностью (N+1 запросов):** 
  Когда вы работаете с коллекциями и обращаетесь к ним в цикле, Hibernate будет делать запрос в базу данных для каждой записи (например, для каждого автора сделает запрос для получения всех книг). Это может привести к большому количеству запросов (N+1 запросов).

  Пример: для каждого автора будет выполнен запрос на подгрузку книг.
```java
List<Author> authors = session.createQuery("from Author", Author.class).getResultList();
for (Author author : authors) {
    for (Book book : author.getBooks()) {
        System.out.println(book.getTitle());
    }
}
```

- **`LazyInitializationException`:** 
  Это исключение возникает, когда вы пытаетесь получить лениво загруженные данные после того, как сессия Hibernate была закрыта. Hibernate не может подгрузить данные, так как сессия, которая управляет объектами, уже закрыта.
  
  Пример:
```java
session.getTransaction().commit();
session.close();
System.out.println(author.getBooks()); // LazyInitializationException
```

#### Как фиксить проблемы, связанные с Lazy Loading?

- **Использование `JOIN FETCH` для загрузки связанных сущностей сразу:** Вы можете использовать **`JOIN FETCH`** в запросах для того, чтобы загрузить связанные сущности в рамках одного запроса, что решает проблему с избыточными запросами и снижает их количество.
```java
List<Author> authors = session.createQuery("from Author a join fetch a.books", Author.class).getResultList();
for (Author author : authors) {
    System.out.println("Author: " + author.getName());
    for (Book book : author.getBooks()) {
        System.out.println("Book: " + book.getTitle());
    }
}
```

- **Использование `Hibernate.initialize()` для предварительной загрузки коллекций:** Если вы не хотите использовать **Eager Loading** или **JOIN FETCH** в запросах, но хотите избежать **`LazyInitializationException`**, можно использовать **`Hibernate.initialize()`**, чтобы инициировать ленивую коллекцию или объект до того, как сессия будет закрыта.
```java
Author author = session.get(Author.class, 1);  // Загружаем автора
Hibernate.initialize(author.getBooks());  // Инициализируем книги
List<Book> books = author.getBooks(); // Теперь можно безопасно работать с книгами
```

## 2. Eager Loading

**Eager Loading** — это подход к загрузке данных, при котором связанные объекты загружаются сразу вместе с основным объектом. В отличие от **Lazy Loading**, при котором связанные объекты загружаются только по мере необходимости, **Eager Loading** загружает всю необходимую информацию заранее. По сути просто полная противоположность Lazy Loading.

#### Когда использовать **Eager Loading**:

1. **Избежание дополнительных запросов**: Если вы знаете, что вам нужно работать с определенными связанными данными, и вам не хочется делать дополнительные запросы к базе данных, чтобы получить эти данные позже.
2. **Оптимизация производительности**: Когда вы хотите избежать проблемы N+1 запросов (когда для каждого элемента выполняется отдельный запрос для получения связанных объектов).
3. **Проблемы с производительностью при Lazy Loading**: Когда используется **Lazy Loading**, каждый запрос к базе данных может требовать дополнительных соединений и времени. Если данные часто нужны вместе, то **Eager Loading** позволяет загружать их все сразу, что может быть более эффективным.
4. **Необходимость в полной информации**: Если вы точно знаете, что все связанные данные вам нужны для текущей операции, то **Eager Loading** позволяет заранее загрузить все нужные объекты.

### **[[Жизненные циклы объектов в Hibernate]]**
(см отдельно)

## **HQL (Hibernate Query Language) и критерии (Criteria API).**

Hibernate Query Language (HQL) и Criteria API — это два основных способа работы с базой данных в Hibernate для выполнения запросов. Оба этих инструмента служат для абстракции SQL-запросов, но они делают это по-разному.

## 1. Hibernate Query Language (HQL)

HQL — это объектно-ориентированный язык запросов, который похож на SQL, но работает с объектами и их полями, а не с таблицами и колонками базы данных. HQL используется для выполнения запросов к базе данных, извлекая данные из сущностей (Java классов, соответствующих таблицам).

#### Что значит работает с объектами и их полями, а не с таблицами и колонками БД?

Когда говорится, что HQL работает с объектами и их полями, а не с таблицами и колонками базы данных, это означает, что в HQL вы оперируете не с прямым представлением таблиц базы данных, как в обычном SQL, а с Java объектами (сущностями), которые могут быть связаны с этими таблицами.

В SQL запросах вы обычно пишете что-то вроде:
```sql
SELECT * FROM users WHERE age > 30;
```
Здесь запрос работает с таблицей `users` и её колонками.

В HQL же запросы пишутся, ориентируясь на Java классы и их поля. Например, если у вас есть сущность `User`(Java класс), то запрос в HQL будет выглядеть так:
```sql
FROM User u WHERE u.age > 30
```
Здесь `User` — это Java класс, а `u.age` — это поле этого класса. Hibernate будет автоматически преобразовывать это в соответствующий SQL-запрос, который будет оперировать таблицей и колонками базы данных, но вы работаете с объектами в коде.

Основное отличие в том, что с HQL вы работаете на уровне объектно-ориентированного подхода, используя имена классов и их поля, а не таблицы и колонки базы данных, как в SQL. Hibernate позаботится о маппинге этих объектов в базу данных.

#### Основные особенности:

- **Объектно-ориентированная синтаксика**: запросы выполняются над сущностями и их аттрибутами, а не над таблицами.
- **Автоматическое преобразование типов**: HQL автоматически преобразует имена классов и поля в соответствующие таблицы и колонки.
- **Пример HQL-запроса**:
```java
String hql = "FROM User u WHERE u.age > 30";
Query query = session.createQuery(hql);
List<User> users = query.list();
```

#### Преимущества HQL:
- Легкость в использовании для простых запросов.
- Понятность и сходство с SQL.
- Поддержка агрегатных функций, объединений и других операций.
#### Недостатки:
- Менее гибкий и динамичный по сравнению с Criteria API.
- Запросы в HQL могут быть сложными для динамической генерации или выполнения.

## 2. Criteria API

Criteria API — это более мощный инструмент для динамического создания запросов в Hibernate. В отличие от HQL, который использует строковое представление запроса, Criteria API предоставляет объектно-ориентированный способ построения запросов через цепочку методов.

#### Основные особенности:

- **Динамическое построение запросов**: это особенно полезно для создания сложных запросов на основе условий, которые могут изменяться в зависимости от входных данных.
- **Типобезопасность**: поскольку запросы строятся с использованием Java объектов, можно избежать ошибок типов.
- **Поддержка Criteria для всех видов запросов** (например, выборка, фильтрация, сортировка).
- **Пример использования Criteria API**:
```java
CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<User> query = builder.createQuery(User.class);
Root<User> root = query.from(User.class);
query.select(root).where(builder.greaterThan(root.get("age"), 30));

List<User> users = session.createQuery(query).getResultList();
```

#### Преимущества Criteria API:
- **Динамичность**: идеально подходит для создания сложных запросов на основе условий.
- **Типобезопасность**: ошибки в запросах выявляются на этапе компиляции.
- **Гибкость**: можно строить запросы с множеством условий и объединений, не беспокоясь о синтаксических ошибках.
#### Недостатки:
- Более сложный и громоздкий синтаксис для простых запросов.
- Может быть трудным в освоении по сравнению с HQL.

## Сравнение HQL и Criteria API:

| Характеристика             | HQL                                       | Criteria API                        |
| -------------------------- | ----------------------------------------- | ----------------------------------- |
| **Тип запросов**           | Строковые запросы                         | Динамическое построение запросов    |
| **Типобезопасность**       | Нет                                       | Да                                  |
| **Гибкость**               | Меньше гибкости для динамических запросов | Высокая гибкость                    |
| **Простота использования** | Легче для простых запросов                | Сложнее для новичков                |
| **Использование**          | Для статических и простых запросов        | Для сложных и динамических запросов |
### Когда использовать HQL:

- Когда запросы простые и не требуют динамической генерации.
- Когда нужно использовать SQL-подобный синтаксис, но с поддержкой объектов.

### Когда использовать Criteria API:

- Когда запросы требуют динамического построения (например, фильтрация на основе пользовательского ввода).
- Когда важно использовать типобезопасность и избежать ошибок на этапе компиляции.

В большинстве случаев для простых запросов достаточно HQL, но для более сложных и динамичных случаев стоит использовать Criteria API.
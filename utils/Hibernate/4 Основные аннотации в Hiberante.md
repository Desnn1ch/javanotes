### Основные аннотации в Hibernate:

1. **`@Entity`**: Аннотирует класс как сущность, которая будет отображена в таблицу базы данных. Используется всегда для классов, которые должны быть сохранены в базе данных. Применяется к классу, который будет отображаться в таблицу базы данных.

```java
@Entity
@Table(name = "users")
public class User {
    // поля и методы
}
```

2. **`@Id`**: Указывает, что это поле является уникальным идентификатором сущности. Используется, чтобы отметить, какое поле будет являться первичным ключом. Применяется к полю класса, которое будет идентификатором сущности.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

3. **`@GeneratedValue`**: Используется для автоматической генерации значений идентификатора (например, автоинкремент). Обычно используется в паре с аннотацией `@Id`. Применяется к полю идентификатора, когда нужно автоматически генерировать значения (например, для автоинкрементных полей).

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

4. **`@Column`**: Указывает на столбец в таблице для данного поля. Опционально можно указать имя столбца, уникальность, nullable и другие параметры. Используется, если необходимо настроить дополнительные параметры для поля (например, задать имя столбца или ограничение на NULL). Таким образом, аннотация `@Column` говорит Hibernate, как поле должно быть связано с определённым столбцом в таблице базы данных
	- **`name`** — это поле в вашем классе.
	- **`user_name`** — это столбец в таблице базы данных, который будет хранить значение этого поля.

```java
@Column(name = "user_name", nullable = false)
private String name;
```
### Аннотации для связей между сущностями:

1. **`@OneToOne`**: Указывает на связь один к одному. Используется, когда одна сущность связана с другой сущностью один к одному (например, каждый пользователь может иметь только один адрес). Address - это тоже entity, ему соответствует таблица addresses, таким образом две таблицы подвязываются по ключу address_id (foreign key)

```java
@OneToOne
@JoinColumn(name = "address_id")
private Address address;
```

2. **`@OneToMany`**: Указывает на связь один ко многим. Используется, когда одна сущность связана с множеством других сущностей (например, один пользователь может иметь много заказов).

```java
@OneToMany(mappedBy = "user")
private Set<Order> orders;
```

3. **`@ManyToOne`**: Указывает на связь многие к одному. Используется, когда множество сущностей связано с одной сущностью (например, многие заказы принадлежат одному пользователю).

```java
@ManyToOne
@JoinColumn(name = "user_id")
private User user;
```

4. **`@ManyToMany`**: Указывает на связь многие ко многим. Используется, когда множество сущностей связано с множеством других сущностей (например, пользователи могут иметь множество ролей, а роли могут принадлежать множеству пользователей).

```java
@ManyToMany
@JoinTable(
  name = "user_role",
  joinColumns = @JoinColumn(name = "user_id"),
  inverseJoinColumns = @JoinColumn(name = "role_id")
)
private Set<Role> roles;
```

### Пример простого класса-сущности:

```java
import javax.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name", nullable = false)
    private String name;

    @ManyToOne
    @JoinColumn(name = "role_id")
    private Role role;

    @OneToMany(mappedBy = "user")
    private Set<Order> orders;

    // Геттеры и сеттеры
}
```

В этом примере:

- Класс `User` является сущностью.
- Он имеет связь с сущностью `Role` через аннотацию `@ManyToOne`.
- Также есть связь с сущностью `Order` через аннотацию `@OneToMany`.

Это базовый пример использования аннотаций в Hibernate для создания сущностей и определения связей между ними.
[Spring Security](https://docs.spring.io/spring-security/reference/servlet/architecture.html) — модуль Spring Framework, предоставляющий механизмы построения систем аутентификации и авторизации, а также другие возможности обеспечения безопасности корпоративных приложений.

## Http-Request lifecycle 

Короче, запрос попадает в контейнер сервлетов (например Tomcat/Jetty и тп), в этом контейнере сервлетов собирается цепочка фильтров, каждый фильтр реализует интерфейс `jakarta.servlet.Filter`. 

Где-то внутри этой цепочки есть `DelegatingFilterProxy`

Там есть `DelegatingFilterProxy`, который регистрируется в контейнере **Spring Boot'ом автоматически**, если в контексте есть бин с именем `"springSecurityFilterChain"`, но сам он ничего не делает, а только ищет **Spring-бин по имени** `"springSecurityFilterChain"` и передает выполнение туда. 

![[Pasted image 20250831190648.png]]

Тем самым Spring добавляет в контейнер сервлетов свои фильтры, точно также реализующие интерфейс `jakarta.servlet.Filter`, которые созданы через Spring Boot автоконфиг.

Далее http-req попадает в `Dispatcher Servlet` и далее картинка:
![[Pasted image 20250831185645.png]]

Ну и ежу понятно что порядок `Filter`’ов важен - они будут применяться последовательно.

## Классы спринговских фильтров и их порядок

- 0 = {`WebAsyncManagerIntegrationFilter`}
    
    Интегрирует `SecurityContext` с `WebAsyncManager`, который ответственен за асинхронные запросы
    
- 1 = {`SecurityContextPersistenceFilter`}
    
    ищет `SecurityContext` в сессии и заполняет `SecurityContextHolder`, если находит контекст. По умолчанию используется класс `ThreadLocalSecurityContextHolderStrategy`, который хранит секурити контекс в `ThreadLocal` переменной
	
- 2 = {`HeaderWriterFilter`}
    
    Добавляет заголовки в респонс.
    
- 3 = {`CsrfFilter`}
    
    пытается предотвратить CSRF-атаки.
    
- 4 = {`LogoutFilter`}
    
	Проверяет, совпадает ли url с паттерном (`[pattern=’/logout’, POST]` по умолчанию) и запускает процедуру логаута:
    - удаляется csrf-токен
    - завершается сессия
    - чистится `SecurityContextHolder`
	
- 5 = {`BasicAuthenticationFilter`}
    
	Проверяет, есть ли в запросе заголовок Authorization с значением, начинающимся на Basic. Если находит, извлекает логин/пароль и передает их в `AuthenticationManager`
    
- 6 = {`RequestCacheAwareFilter`}
    
    Этапы работы фильтра:
    - пользователь заходит на защищенный url
	- его перекидывает на страницу логина
	- после успешной авторизации пользователя кидает на страницу которую он запрашивал
	
	Фильтр нужен для восстановления оригинального запроса.
	
	Внутри проверяется, есть ли сохраненный запрос, и если он есть, то им подменяется текущий.
	
	Запрос сохраняется в `Session`.

- 7 = {`SecurityContextHolderAwareRequestFilter`} - я честно хз зачем он здесь .-. ну он оборачивает `HttpServletRequest` в `HttpServletRequestWrapper`. Это класс-обертка (ну декоратор крч) от Java EE
    
- 8 = {`AnonymousAuthenticationFilter`}
    
    Если к моменту выполнения этого фильтра `SecurityContextHolder` пустой, то есть аутентификация не прошла, фильтр заполняет `SecurityContextHolder` анонимной аутентификацией - `AnonymousAuthenticationToken` с ролью `ROLE_ANONYMOUS`.
    
    Это гарантирует, что в `SecurityContextHolder` будет объект, то есть не будет null-эксепшенов, а также добавляет гибкости к настройке доступа для неавторизованных пользователей.
    
- 9 = {`SessionManagementFilter`}
    
    На этом этапе фильтр производит действия, связанные с сессией. Это может быть смена идентификатора сессии, ограничение количества одновременных сессий, сохранение `SecurityContext` в `SecurityContextRepository`.
    
    В обычном случае происходит следующее:
	- `SecurityContextRepository` сохраняет `SecurityContext` в `Session`.
	- Вызывается `SessionAuthenticationStrategy.onAuthentication()`
	    Происходят две вещи:
	    1. По умолчанию включена защита от session fixation attack *(эта атака возможна, когда ***_не заменяется session token при переходе анонимной сессии пользователя в аутентифицированную)_, т.е. после аутентификации меняется id сессии
	    2. Если был передан csrf токен, то сгенерируется новый
	
- 10 = {`ExceptionTranslationFilter`}
    
	К этому моменту SecurityContext должен содержать какую-либо аутентификацию. Этот фильтр обрабатывает возможные ошибки авторизации
    
- 11 = {`FilterSecurityInterceptor`}
    
	На последнем этапе происходит авторизация на основе url-запроса. Фильтр решает, имеет ли текущий пользователь доступ до запрашиваемого url.
    
    Есть еще другая реализация — `MethodSecurityInterceptor`, ответственный за допуск до вызова метода (при использовании аннотаций `@PreAuthorize`, `@Secured`)

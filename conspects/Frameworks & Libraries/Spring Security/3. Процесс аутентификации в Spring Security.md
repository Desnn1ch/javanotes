## Предисловие

На 5-ом фильтре = {`BasicAuthenticationFilter`} проверяет, есть ли в запросе заголовок Authorization с значением, начинающимся на Basic. Если находит, извлекает логин/пароль и передает их в `AuthenticationManager`

## Процесс аутентификации

`SecurityContext` — интерфейс, задающий минимальные методы для хранения сведений о текущем аутентифицированном пользователе (`Principle`’е, но хранится в классе интерфейс `Authentication`) 

`SecurityContextHolder` — класс, обеспечивающий доступ к `SecurityContext`. Ассоциирует `SecurityContext` с текущим `ThreadLocal`’ом. Ну то есть теперь `SecurityContext` доступен из любых методов текущего потока.

(подробнее [[4. Иерархия `SecurityContextHolder`]])

Короче он управляет жизненным циклом `SecurityContext`, и можно задавать, как JVM-ине хавать этот контекст.

Если в `SecurityContextHolder` че-то лежит, то Spring Security использует этот класс как текущего аутентифицированного пользователя.

`FilterChainProxy`, описанный наверху, гарантирует, что `SecurityContext` по завершении всегда будет очищен.

### **AuthenticationManager**

К нему обращается `BasicAuthenticationFilter`, конкретно он проверяет, есть ли в запросе заголовок Authorization с значением, начинающимся на Basic. Если находит, извлекает логин/пароль и передает их в `AuthenticationManager`

`AuthenticationManager` - API, задающая, как фильтры от Spring Security должны совершать аутентификацию.

Это интерфейс, у которого есть метод 
`Authentication authenticate(Authentication authentication)`

### **ProviderManager**

Это имплементация `AuthenticationManager`'а. Внутри содержит лист `AuthenticationProvider`’ов (внизу есть пикча прикольная) - это интерфейс, который задает метод для какой-то конкретной аутентификации. Например, одна из его реализаций - `DaoAuthenticationProvider` - поддерживает username/password аутентификацию, а `JwtAuthenticationProvider`, не поверите, аутентификацю через JWT. (см [[5. Виды AuthentificationProvider-ов]])

Вобщем здесь мы можем задать несколько видов аутентификации и это удобно.

Когда мы передаем объект `Authentication` в `ProviderManager`, он перебирает все существующие `AuthenticationProvider`’ы и проверяет, поддерживает ли провайдер данную имплементацию `Authentication` (у `AuthenticationProvider`’а есть метод `boolean supports(Class<?> authentication)`)

**Задача каждого конкретного `AuthenticationProvider`** — уже **проверить данные пользователя и построить корректный `Authentication`**.

То есть конечная цель не "просто достать credentials" или "достать UserDetails".  
Конечная цель — **создать "успешный" `Authentication` с:**

- правильным `principal` (обычно `UserDetails` или `Jwt`)
- валидными `authorities` (роли/права)
- `isAuthenticated = true`

Если аутентификация не удалась, выбрасывается исключение, которое поймает `ProviderManager` и попробует следующий `AuthenticationProvider`, если никто не сможет ничего сделать - пробрасывается последнее пойманное исключение.

Далее BasicAuthenticationFilter сохраняет полученный Authentication в SecurityContextHolder.


Вот например так выглядит для `DaoAuthentificationProvider` метод `authentificate`:
```java
public Authentication authenticate(Authentication authentication) {
   UserDetails user = retrieveUser(username,
                             (UsernamePasswordAuthenticationToken) authentication);
   additionalAuthenticationChecks(user,
                           (UsernamePasswordAuthenticationToken) authentication);
   return createSuccessAuthentication(principalToReturn, authentication, user);
}
```

Этот метод получает объект `UserDetails` из базы данных с помощью кастомной реализации `UserDetailsService`.
```java
protected final UserDetails retrieveUser(
		String username,
        UsernamePasswordAuthenticationToken authentication) {
        
   UserDetails loadedUser = 
		   this.getUserDetailsService().loadUserByUsername(username);
		   
   return loadedUser;
}
```

После успешной проверки пароля этот метод создаёт объект `Authentication` с Authorities (правами/ролями) и выставляет флаг `isAuthenticated` в `true`.
```java
protected Authentication createSuccessAuthentication(
		Object principal,
        Authentication authentication, UserDetails user) {
        
	UsernamePasswordAuthenticationToken result = 
	new UsernamePasswordAuthenticationToken(principal,authentication.getCredentials(),
	authoritiesMapper.mapAuthorities(user.getAuthorities()));
	
   return result;
}
```

Метод `createSuccessAuthentication()` создаёт следующий объект `Authentication`:

- `principal = username`
- `credentials = password`
- `authorities = REGULAR_USER`
- `isAuthenticated = true`

`AuthenticationProvider` возвращает объект `Authentication` в `AuthenticationManager`.
Если же был успешно получен объект `Authentication`, то выполняются следующие шаги:

1. Объект `Authentication` сохраняется в `SecurityContextHolder`.
2. Вызывается обработчик успешной аутентификации (`success-handler`).

Вот тут круто описано это все: https://ducmanhphan.github.io/2019-02-09-The-mechanism-of-spring-security/

### Короче:

1. Клиент отправляет запрос с логином/паролем (например, POST `/login`).
2. **AuthenticationFilter** (например `UsernamePasswordAuthenticationFilter`) создаёт «сырой» токен `UsernamePasswordAuthenticationToken(username, password)`.
3. Этот токен передаётся в **AuthenticationManager** (обычно это `ProviderManager`).
4. `AuthenticationManager` передаёт токен подходящему **AuthenticationProvider**.  
    5–8. `AuthenticationProvider` использует `PasswordEncoder` и `UserDetailsService` для проверки пользователя.
5. Если проверка успешна — `AuthenticationProvider` возвращает **новый `Authentication`** с данными юзера.
6. `AuthenticationManager` возвращает успешный объект обратно в фильтр.
7. Фильтр сохраняет этот `Authentication` в **SecurityContext** → теперь пользователь считается аутентифицированным.

![[Screenshot 2025-08-31 at 22.54.00.png]]


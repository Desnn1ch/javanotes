### Что такое IoC?

**Inversion of Control** — инверсия контроля управления. Это принцип, при котором управление объектами передается контейнеру или фреймворку.

Почему инверсия? Теперь не мы вызываем кучу методов для работы с библиотекой, а наоборот фреймворк делает вызовы к нашему коду.

### Что такое DI?

DI — Dependency Injection — Внедрение зависимостей. Паттерн/механизм реализующий принцип IoC. Вместо того чтобы вручную прописывать зависимости, Spring это делает сам.

**Виды DI**:
1. **Constructor-based dependency injection**
	- При создании объекта все зависимости должны быть переданы в конструктор
	- Поля могут быть final
	
2. **Field-based dependency injection**
	- Внедрение после создания объекта. Spring делает это с помощью рефлексии
	- Поля не могут быть final
	
3. **Setter-based dependency injection**
	- Внедрение после создания объекта. Spring делает это с помощью сеттеров
	- Поля не могут быть final

### Почему не рекомендуется Field Injection?

Если сделать `@Autowired` над полем, то получим сообщение `Field Injection Not Recommended`. Почему все говорят, что `Constructor Injection` лучше чем `Field Injection`?

###### **1 `Immutability`**

Используя `Field Injection` невозможно создать `immutable class`

###### **2 `NullPointerException`**

Если делаем `Field-based dependency injection`, то у класса теперь есть неявно созданный пустой конструктор, потому что при отсутствии конструкторов Java сама генерирует его. 

Хотелось бы, чтобы его не было, т.к. это может привести к `NullPointerException`. 

###### **3 Привязка к Spring**

Используя `constructor-based dependency injection`, мы можем пользоваться классом как обычным, если вдруг захотим создать объект вручную. 

С полем так не получится, то есть так мы можем создавать только через спринг или используя рефлексию, но это ваще дичь. (Или дефолтный конструктор, см выше null pointer). 

А нам хотелось бы уметь использовать класс без спринга — в тестировании было бы грустно поднимать спринг контекст, т.к. это тяжелая операция, поэтому хочется зависимости прописать ручками, а с Field injection это будет крайне проблематично

### Бины и контейнеры

- Beans (бины) — объекты, управляемые контейнером Spring.
- Container (контейнер или контекст Spring) — управляет жизненным циклом и конфигурацией бинов

### `BeanFactory` & `ApplicationContext`

`BeanFactory` — центральный интерфейс Spring для доступа к контейнеру. Основной метод — `getBean`

`ApplicationContext` - дочерний интерфейс `BeanFactory`. Отличия:

- Можем получать бины из контейнера.
- В отличие от BeanFactory, где бины загружаются по требованию, все бины загружаются при старте.
- Есть автоматическая регистрация бинов

Реализации `ApplicationContext`:
1. `ClassPathXmlApplicationContext` - загружает бины из XML-файлов, которые лежат в classpath
	
2. `AnnotationConfigApplicationContext`
	- Загружает бины из классов конфигурации @Configuration
	- используется в В _stand-alone_ приложениях (консоль, тесты, batch-задачи)
	- работает только с java config
	 
3. `AnnotationConfigWebApplicationContext`
	- То же самое, но с поддержкой web окружения.
	- Например, умеет работать с сервлетами (setServletContext)
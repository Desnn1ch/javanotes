## 1. Spring создаёт обычный объект

Допустим, у тебя есть сервис:

```java
@Service
public class OrderService {

    @Transactional
    public void createOrder() {
        System.out.println("Создание заказа");
    }
}
```

Spring просто вызывает `new OrderService()` и получает "сырой" объект.  
На этом этапе **никакой транзакционности ещё нет**.

---

## 2. В дело вступает `BeanPostProcessor`

Spring регистрирует кучу стандартных `BeanPostProcessor`.  
Например:

- `AnnotationAwareAspectJAutoProxyCreator` — ищет аннотации типа `@Transactional`, `@Async`, `@Cacheable`.
- `AutowiredAnnotationBeanPostProcessor` — обрабатывает `@Autowired`.
- и т. д.

`AnnotationAwareAspectJAutoProxyCreator` реализует метод:

```java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) {
    if (нужно_обернуть_в_прокси(bean)) {
        return createProxy(bean);
    }
    return bean;
}
```

---

## 3. Создание прокси

Если бин помечен аннотацией (`@Transactional` и т.п.), Spring вместо оригинала возвращает **прокси-объект**.

Внутри используется **JDK dynamic proxy** (если класс реализует интерфейсы) или **CGLIB** (если нет интерфейсов).

Пример с JDK Proxy (упрощённо):

```java
OrderService proxy = (OrderService) Proxy.newProxyInstance(
    OrderService.class.getClassLoader(),
    new Class<?>[]{OrderService.class},
    (Object proxyObj, Method method, Object[] args) -> {
    
        if (method.isAnnotationPresent(Transactional.class)) {
        
            // Открыть транзакцию
            System.out.println("Начало транзакции");
            Object result = method.invoke(bean, args);
            
            // Закрыть транзакцию
            System.out.println("Коммит транзакции");
            return result;
        }
        return method.invoke(bean, args);
    }
);
```

То есть: вместо настоящего `OrderService` в контейнере будет храниться **прокси**.

---

## 4. Использование прокси

Когда где-то в коде мы делаем:

`@Autowired private OrderService orderService;`

На самом деле в поле попадёт **прокси-объект**, а не реальный `OrderService`.

И при вызове:

`orderService.createOrder();`

→ вызов перехватывает прокси, выполняет «дополнительную логику» (открыть транзакцию, зафиксировать/откатить, добавить логирование, выполнить асинхронно и т.д.), а потом уже вызывает **оригинальный метод**.

---

## 5. Итог

- `BeanPostProcessor` обнаруживает, что бин нужно «особым образом обернуть».
- Создаётся прокси (через JDK Proxy или CGLIB).
- В контейнер вместо оригинала регистрируется прокси.
- Все вызовы методов проходят через прокси → и здесь Spring вшивает нужное поведение (AOP, транзакции, security, async).
Spring MVC — модуль Spring Framework, обеспечивающий архитектурный подход Model-View-Controller при помощи слабо связанных готовых компонентов.

Про MVC (архитектуру) читать [тут](https://habr.com/ru/articles/321050/), это минут на 20-25, но подробно и понятно (можно не читать)

Щас будет больно, терпите:

### Предисловие

Spring MVC построен вокруг центрального сервлета — **Dispatcher Servlet**. Реализуется паттерн Front Controller: `DispatcherServlet` распределяет запросы по контроллерам (другим сервлетам).

- `Handler` — абстрактное понятие, в спринге им может быть любой `Object` (для поддержки работы с разными фреймворками). Но по сути это методы, которые будут непосредственно обрабатывать запрос, то есть это — методы контроллера.
    
- `HandlerInterceptor` — интерфейс, который будет вызван до и после того, как класс `HandlerAdapter`применит настоящий handler.
    
	Используется, например, для проверки авторизации, или изменения временной зоны (locale) и темы (theme). Короче, чтобы не делать это все в хендлере, делаем это отдельно тут
    
- `HandlerMapping` — интерфейс для определения, какому handler’у нужно обработать данный запрос. Буквально весь его функционал.
    
	Две основные реализации, поставляемые спрингом:
	-  `BeanNameUrlHandlerMapping`  - маппит URL на **имя бина**, сейчас почти не применяют
	-  `RequestMappingHandlerMapping` - самый главный и часто используемый. Работает с аннотациями `@RequestMapping`, `@GetMapping`, `@PostMapping` и т.п. То есть именно он находит методы контроллеров по URL, HTTP-методу. В современных приложениях — основной `HandlerMapping`.
    
- `HandlerAdapter` — интерфейс для непосредственно обработки запроса нужным хендлером.
    
    По умолчанию спрингом поставляются `HttpRequestHandlerAdapter` и `SimpleControllerHandlerAdapter`.
    
- `HandlerExecutionChain` — содержит в себе handler’ов и handler interceptor’ов

###  **Сам жизненный цикл запроса**:

1. Все запросы поступают сначала в `DispatcherServlet`. Затем он перебирает доступные ему экземпляры `HandlerMapping`, и посылает нужному `HandlerMapping`’у этот запрос, чтобы получить handler’а для обработки этого запроса. То есть `DispatcherServlet` тыкает метод `HandlerMapping`’а: `getHandler(HttpServletRequest request)`, после чего ему выдается `HandlerExecutionChain`.
	
2. Дальше `DispatcherServlet` определяет нужный `HandlerAdapter` в зависимости от хэндлера.
	
3. Затем вызывается (еще не `HandlerAdapter`’ом) метод `preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler)` для каждого `HandlerInterceptor` из полученного `HandlerExecutionChain`. 
	
4. Наконец, вызываем у `HandlerAdapter`’а метод `handle(HttpServletRequest req, HttpServletResponse resp, Object handler)` уже с настоящим handler’ом.
	
5. Метод-обработчик запроса выполняется и возвращает класс `ModelAndView`, который в себе содержит String-имена View и Model, но также может содержать и сами их классы. _Если мы работаем с RESTful-методом, то возвращается null, и пропустится следующий шаг._ То есть у нас ответ будет сразу содержаться во втором параметре метода — `HttpServletResponse resp`.
	
6. Вызывается `ViewResolver` для того, чтобы достать нужный View из класса `ModelAndView`.
	
7. Перед завершением обработки запроса, для каждого `HandlerInterceptor`’а из `HandlerExecutionChain`вызывается метод для пост-обработки `postHandle(HttpServletRequest req, HttpServletResponse resp, Object handler)`.
    
8. Если в ходе обработки запроса выбрасывается исключение, то оно обрабатывается с помощью одной из реализаций интерфейса `HandlerExceptionResolver`.
    
    По умолчанию спринг поставляет `ExceptionHandlerExceptionRespover` и `ResponseStatusExceptionResolver`, `DefaultHandlerExceptionResolver`.
    
9. _В случае классического Controller’а_ (не помеченного как RESTful (`@RestController`)), после того, как View создан, `DispatcherServlet` отправляет полученные данные в виде атрибутов в View, который в конечном счете записывается в наш респонс - `HttpServletResponse`.

![[Screenshot 2025-09-02 at 18.36.10.png]]
**REST API** — это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их более удобными и производительными.

Слово REST — акроним от Representational State Transfer, что переводится на русский как «передача состояния представления», «передача репрезентативного состояния» или «передача „самоописываемого“ состояния».

В отличие от, например, SOAP API, REST API — не протокол, а простой список рекомендаций, которым можно следовать или не следовать.

## Принципы REST API:

### 1 Клиент-серверная модель

Принцип означает, что клиент (может быть чем угодно, браузер, мобильное приложение и тп) и сервер (место где хранятся данные и логика обработки) разделены. Клиент запрашивает информацию, сервер ее обрабатывает и отправляет ответ.

**Пример**:
- Клиент делает запрос на `https://api.example.com/users/1`
- Сервер ищет пользователя с ID = 1 и отправляет ответ.
- Клиент получает данные и отображает их на экране.

### 2 Отсутствие состояния (Stateless)

У сервера нет никакого состояния, те каждый запрос обрабатывается сервером независимо от всех предыдущих запросов, без сохранения информации о предидущих запросах, сервер не помнит что клиент делал раньше

### 3 Кеширование

Сервер имеет право кешировать данные, чтобы каждый раз не собирать их и не тратить свои ресурсы на это. Сервер сохраняет часть данных у клиента или на промежуточных серверах. При этом не нужно кешировать всю информацию подряд, тк это приведет к излишней трате памяти, именно поэтому каждый ответ от сервера имеет пометку о том, можно ли его кешировать

### 4 Единообразие интерфейса

Единообразие интерфейса в REST API — это **общий принцип**, который включает в себя **всё**

1. **Структуру URL** (эндпоинты, способы обращения к ресурсам)
2. **Методы HTTP** (GET, POST, PUT, DELETE и их правильное использование)
3. **Формат данных** (например, JSON, XML)
4. **Единые принципы обработки запросов и ответов** (какие коды состояния возвращать, как передавать ошибки и метаданные)
5. **HATEOAS** (механизм, позволяющий клиенту узнавать, какие действия можно выполнять с ресурсом)

Например, мы хотим добавить в наш сервис новую функциональность для просмотра данных о денежных переводах. Понятно, что логика интерфейса для обращения к ним должна быть такой же, как и для всего, что было в сервисе раньше.

Ответ на запросы к новому ресурсу должен приходить в том же формате, что и к старым, и сразу же содержать дополнительную информацию: что разрешается делать с ресурсом, можно ли его изменять и удалять на сервере и так далее.

### 5 Многоуровневая система

Структура сервера зачастую сложнее, чем один сервер. Между клиентом и сервером может быть еще n-ное кол-во прокси-серверов, которые могут выполнять самую разную работу, будь то кэширование, обеспечение безопасности, дополнительная обработка данных. 

Бывает так, что основных серверов несколько - тогда существуют дополнительные серверы-балансировщики, который распределяют разгрузку между ними.

Из всей цепочки никто не знает работает он с основным сервером или с прокси

### 6 Опциональная передача кода на клиент (Code-on-Demand)

Этот принцип означает, что сервер в ответ на запрос может **отправить исходный код**, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.
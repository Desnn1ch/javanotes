Файл **.class**, содержащий байт-код, это строго структурированный бинарник, грубо говоря исполняемый файл для JVM

**Сначала много инфы, в конце будет пример, как это все работает вместе**
## Структура .class файла

**u2** - беззнаковое 2-байтовое число
**u4** - беззнаковое 4-байтовое число

| Смещение (Offset) | Тип данных         | Назначение                                                     | Пример значения/Описание                                                                                 |
| ----------------- | ------------------ | -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **0x0000**        | `u4`               | **magic** (магическое число)                                   | `0xCAFEBABE` — уникальная сигнатура, которая говорит: "Это файл класса Java!"                            |
| **0x0004**        | `u2`               | **minor_version** (минорная версия)                            | `0x0000`                                                                                                 |
| **0x0006**        | `u2`               | **major_version** (мажорная версия)                            | `0x003D` (61) — означает, что класс скомпилирован для Java 17 (60 - Java 16, 61 - Java 17, 62 - Java 18) |
| **0x0008**        | `u2`               | **constant_pool_count** (количество записей в пуле констант)   | `0x002F` (47) — значит, в пуле 46 записей (счетчик с 1, запись #0 не используется)                       |
| **0x000A**        | `cp_info[]`        | **constant_pool** (сам пул констант)                           | Массив структур, каждая со своим тегом и данными. **Самый важный раздел!**                               |
| ...               | `u2`               | **access_flags** (флаги доступа к классу)                      | `0x0021` (ACC_PUBLIC \| ACC_SUPER)                                                                       |
| ...               | `u2`               | **this_class** (индекс в constant_pool на этот класс)          | `0x0005` — смотри запись #5 в пуле констант, чтобы узнать имя этого класса                               |
| ...               | `u2`               | **super_class** (индекс в constant_pool на родительский класс) | `0x0006` — смотри запись #6 (обычно `java/lang/Object`)                                                  |
| ...               | `u2`               | **interfaces_count** (количество интерфейсов)                  | `0x0000`                                                                                                 |
| ...               | `u2`               | **interfaces[]** (индексы интерфейсов в constant_pool)         | Массив индексов                                                                                          |
| ...               | `u2`               | **fields_count** (количество полей)                            | `0x0000`                                                                                                 |
| ...               | `field_info[]`     | **fields** (метаданные полей)                                  | Массив структур с информацией о каждом поле класса                                                       |
| ...               | `u2`               | **methods_count** (количество методов)                         | `0x0002` — например, методы `main` и `<init>` (конструктор)                                              |
| ...               | `method_info[]`    | **methods** (метаданные методов)                               | Массив структур. Для каждого метода здесь хранится его **байт-код**!                                     |
| ...               | `u2`               | **attributes_count** (количество атрибутов)                    | `0x0001`                                                                                                 |
| ...               | `attribute_info[]` | **attributes** (атрибуты класса)                               | Например, `SourceFile` (имя исходного файла)                                                             |
## ConstantPool

1. Пул-констант - это таблица (массив) структур, на которые по индексу ссылаются все другие части .class-файла:
	- Код методов
	- Описание классов
	- Описание полей и методов
2. Здесь хранятся строковые константы, имена классов, интерфейсов, полей, методов и другие константы, которые есть в структуре .class-файла и ее подструктурах. 
3. Каждый элемент пула констант начинается с однобайтового тега, определяющего тип константы. В зависимости от типа константы следующие байты могут быть непосредственным значением константы или ссылкой на другой элемент в пуле.
4. **Индексация начинается с 1, а не 0** - Если есть ссылка на 0, то это рассматривается JVM, как ошибка.
Благодаря наличию ConstantPool строки и константы не дублируются, все константы в одном месте.

### Типы записей в ConstantPool
#### a) `CONSTANT_Utf8` (Тэг = 1)

Хранит строку в модифицированной кодировке UTF-8.

- **Структура:**
    
    - `u1 tag`; // Значение `1`
        
    - `u2 length`; // Длина строки _в байтах_
        
    - `u1 bytes[length]`; // Непосредственно байты строки
        
- **Что хранит:** Буквально любые строки: имена классов (`"java/lang/Object"`), имена методов и полей (`"main"`, `"add"`), дескрипторы методов (`"(I)I"`), строковые литералы (`"Hello World"`) и т.д.
    
- **Пример:** `#7 = Utf8 "()V"` — дескриптор метода, который ничего не принимает и возвращает `void`.
    

#### b) `CONSTANT_Integer` (Тэг = 3), `CONSTANT_Float` (Тэг = 4)

Хранят числовые константы типа `int` и `float`.

- **Структура:**
    
    - `u1 tag`; // `3` или `4`
        
    - `u4 bytes`; // Число, сохраненное в big-endian формате.
        
- **Пример:** `#2 = Integer 42`
    

#### c) `CONSTANT_Long` (Тэг = 5), `CONSTANT_Double` (Тэг = 6)

Хранят числовые константы типа `long` и `double`.

- **Важная особенность:** Эти записи занимают **два слота** в пуле констант. Если следующая запись имеет индекс `#5`, то после `CONSTANT_Long` на индексе `#4` следующая запись будет иметь индекс `#6`.
    
- **Структура:**
    
    - `u1 tag`; // `5` или `6`
        
    - `u4 high_bytes`; // Старшие 4 байта
        
    - `u4 low_bytes`; // Младшие 4 байта
        

#### d) `CONSTANT_Class` (Тэг = 7)

Хранит ссылку на класс или интерфейс.

- **Структура:**
    
    - `u1 tag`; // `7`
        
    - `u2 name_index`; // **Индекс** на запись `CONSTANT_Utf8`, которая содержит полное имя класса в формате JVM (с `/` вместо `.`).
        
- **Пример:** `#6 = Class #35 // #35 = Utf8 java/lang/Object`  
    Запись `#6` не хранит строку "java/lang/Object". Она лишь ссылается на запись `#35`, где эта строка лежит.
    

#### e) `CONSTANT_String` (Тэг = 8)

Хранит ссылку на строковый литерал.

- **Структура:**
    
    - `u1 tag`; // `8`
        
    - `u2 string_index`; // **Индекс** на запись `CONSTANT_Utf8`, которая содержит саму строку.
        
- **Пример:** `#8 = String #9 // #9 = Utf8 "Hello World"`
    

#### f) `CONSTANT_Fieldref` (Тэг = 9), `CONSTANT_Methodref` (Тэг = 10), `CONSTANT_InterfaceMethodref` (Тэг = 11)

**Самые важные записи для ссылок на поля и методы.** Их структура одинакова.

- **Структура:**
    
    - `u1 tag`; // `9`, `10` или `11`
        
    - `u2 class_index`; // **Индекс** на запись `CONSTANT_Class`, которая представляет класс, объявляющий поле или метод.
        
    - `u2 name_and_type_index`; // **Индекс** на запись `CONSTANT_NameAndType`, которая описывает имя и тип.
        
- **Пример:** `#1 = Methodref #6.#15 // #6=Class java/lang/Object, #15=NameAndType "<init>":()V`  
    Эта запись говорит: "Метод, находящийся в классе `java/lang/Object`, с именем `<init>` (специальное имя конструктора) и дескриптором `()V` (не принимает аргументов, возвращает void)".
    

#### g) `CONSTANT_NameAndType` (Тэг = 12)

Связывает имя с дескриптором. Нужна для полного описания поля или метода.

- **Структура:**
    
    - `u1 tag`; // `12`
        
    - `u2 name_index`; // **Индекс** на `CONSTANT_Utf8` (имя поля/метода)
        
    - `u2 descriptor_index`; // **Индекс** на `CONSTANT_Utf8` (дескриптор поля/метода)
        
- **Пример:** `#15 = NameAndType #7:#8 // #7=Utf8 "<init>", #8=Utf8 "()V"`

## Как это работает вместе

**Java-код**

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
```

**Как будет выглядеть ConstantPool**

```
   #1 = Methodref          #6.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #18            // "Hello"
   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #21            // Main
   #6 = Class              #22            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               SourceFile
  #14 = Utf8               Main.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = Class              #23            // java/lang/System
  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;
  #18 = Utf8               Hello
  #19 = Class              #26            // java/io/PrintStream
  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V
  #21 = Utf8               Main
  #22 = Utf8               java/lang/Object
  #23 = Utf8               java/lang/System
  #24 = Utf8               out
  #25 = Utf8               Ljava/io/PrintStream;
  #26 = Utf8               java/io/PrintStream
  #27 = Utf8               println
  #28 = Utf8               (Ljava/lang/String;)V
```

**Как JVM понимает вызов `System.out.println("Hello")` в байт-коде?**  
Байт-код содержит инструкции, использующие индексы пула, например, `ldc #3` (загрузить константу #3) и `invokevirtual #4` (вызвать виртуальный метод #4).

1. **`invokevirtual #4`**: JVM смотрит на запись `#4`.
    
2. `#4` является `Methodref` и состоит из `#19` (класс) и `#20` (имя и тип).
    
3. Смотрим `#19`: это `Class`, ссылающийся на `#26` (`Utf8 "java/io/PrintStream"`). Класс найден (Найден он на этапе Resolution в [[Class Loading]]).
    
4. Смотрим `#20`: это `NameAndType`, состоящий из `#27` (имя) и `#28` (дескриптор).
    
    - `#27` -> `Utf8 "println"`
        
    - `#28` -> `Utf8 "(Ljava/lang/String;)V"`
        
5. JVM теперь знает точный адресат: нужно вызвать метод с именем `println` в классе `java.io.PrintStream`, который принимает `String` и возвращает `void`.
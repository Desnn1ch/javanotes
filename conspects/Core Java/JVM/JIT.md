1. Just in time компиляция. При интерпретации методов JVM проводит профилирование методов. Когда метод вызвался более n раз, он помечается, как **Hot** **Spot.** Затем метод отправляется в «очередь на компиляцию». Компиляция происходит в фоновом потоке.
2. Современные JVM используют многоуровневую компиляцию:
	 - C1 Compiler (Client Compiler) - быстрый компилятор, он компилирует с минимальной оптимизацией. 
	 - C2 Compiler (Server Compiler) - медленный, но ебать какой умный компилятор, делает все мега оптимизированным. Не вдаваясь в подробности, анализирует результаты профилирования JVM для последующего ускорения кода
3. Скомпилированный машинный код помещается в специальную область памяти - **CodeCache** (**ОН НЕ ЧАСТЬ Runtime Data Areas**, то есть выделяется в нативной памяти)
4. Теперь JVM нужно атомарно подменить адрес метода (**code_ptr**) в структуре метода, хранящейся в **Method Area** ([[Runtime Data Areas]]). Теперь **code_ptr** указывает не на код интерпретатор, который знает как исполнять метод, а на машинный код самой функции.
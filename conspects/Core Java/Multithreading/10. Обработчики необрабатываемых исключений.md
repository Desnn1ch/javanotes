**Если поток выбросил `RuntimeException` (или любое непойманное исключение):**

1. JVM передаёт его в `UncaughtExceptionHandler` (если он есть).
2. Если обработчика **нет**, JVM просто напечатает stack trace в `stderr`.
3. Поток **заканчивает работу навсегда** (состояние → `TERMINATED`).

![[Screenshot 2025-08-25 at 00.10.52.png]]
Пример:
```java
import static java.lang.System.out;

public final class Runner {
    private static final String MESSAGE_EXCEPTION_TEMPLATE =
            "Exception was thrown with message '%s' in thread '%s'.%n";

    public static void main(final String... args) {
        final Thread.UncaughtExceptionHandler uncaughtExceptionHandler =
                (thread, exception) -> out.printf(
                        MESSAGE_EXCEPTION_TEMPLATE,
                        exception.getMessage(),
                        thread.getName()
                );

        final Thread thread = new Thread(new Task(), "worker-thread");
        thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);

        thread.start();
    }

    private static final class Task implements Runnable {
        private static final String EXCEPTION_MESSAGE = "I am exception";

        @Override
        public void run() {
            throw new RuntimeException(EXCEPTION_MESSAGE);
        }
    }
}
```
Вывод:
```java
Exception was thrown with message 'I am exception' in thread 'worker-thread'.

Process finished with exit code 0
```

Также можно устанавливать ``UncaughtExceptionHandler`` по дефолту методом ``Thread::setUncaughtExceptionHandler``

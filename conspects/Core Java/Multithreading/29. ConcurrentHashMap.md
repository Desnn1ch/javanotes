Начнем с того, что синхронизированные коллекции типа `Vector`, `Stack` и всякой прочей залупы ебаной - ебаное говно, потому что:
1. Они синхронизированы только в рамках своих методов, это значит что если у нас есть метод, который состоит из двух операций этой самой коллекции - нам придется его синхронизировать дополнительно
2. Они синхронизированы всегда на всех методах - это неэффективно. 

### `ConcurrentHashMap`

Коротко почему `SynchronizedMap` полное говно в сравнении с `ConcurrentHashMap`:
![[Screenshot 2025-08-28 at 17.38.00.png]]

Стоит оговориться, что в `ConcurrentHashMap` потоки `reader`-ы никогда и никаким образом не блочатся, а это значит, что есть риск того, что они достают старые значения. Это нормально и соответствует _weak consistency_.
![[Screenshot 2025-08-28 at 17.40.53.png]]

Если же у какого-то бакета `Entry = null`, тогда возможна вот такая ситуация:
![[Screenshot 2025-08-28 at 17.51.23.png]]
И на самом деле метод внутри решает эту проблему с помощью `CAS`. А именно:
1. Сначала один из потоков вставит элемент
2. Второй перед вставкой увидит, что `Entry != null`
3. Второй просто вставит по обычному алгоритму:![[Screenshot 2025-08-28 at 17.53.16.png]]

Для потокобезопасной записи в `ConcurrentHashMap` используется метод `merge`
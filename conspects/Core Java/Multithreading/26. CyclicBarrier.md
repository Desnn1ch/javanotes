Допустим у нас есть большая таска, и она разбивается на k более меньших. Каждая сабтаска разбивается на еще сабсабтаски вот таким образом:
![[Screenshot 2025-08-28 at 15.14.54.png]]

k потоков выполняют k сабтасок. И мы решили синхронизировать выполнение сабсабтасок по потокам, таким образом, чтобы они не приступали к например leaf_task_2, прежде чем все потоки не выполнят leaf_task_1, вот таким образом
![[Screenshot 2025-08-28 at 15.16.49.png]]

С этим нам и поможет `CyclicBarrier`:

- `CyclicBarrier` принимает в свой конструктор кол-во потоков, которые необходимо синхронизировать, в нашем случае это число равно k.
- `CyclicBarrier` уменьшает значение счетчика, когда один из потоков закончил сабсабтаску, и этот поток блокируется
- Когда значение = 0 - `CyclicBarrier` отблочивает все потоки и возвращает свое значение по умолчанию
- Также в конструктор `CyclicBarrier` можно воткнуть `Runnable`, который будет выполняться, когда счетчик внутри `CyclicBarrier` равен нулю, причем этот `Runnable` будет выполняться именно последним закончившим сабсабтаску потоком (на скрине ниже норм показано)![[Screenshot 2025-08-28 at 15.30.46.png]]
- Также `CyclicBarrier::await` может выкинуть 2 exception-a: `InterruptedException` и `BrokenBarrierException`. Когда один поток пытается интераптнуть второй поток в барьере, второй кидает `InterruptedException`, а все остальные потоки, которые были заблочены барьером, кидают `BrokenBarrierException`
- Ну и очев, что когда какой-то поток был заблочен методом `CyclicBarrier::await`, и был прерван, барьер считается разрушенным
- И все последоющие попытки вызвать ``CyclicBarrier::await`` приведут к `BrokenBarrierException`![[Screenshot 2025-08-28 at 15.38.42.png]]

### Кодинг

Можно посмотреть в видео: https://www.youtube.com/watch?v=cNe6vgKupQs&list=PLqnlz-HutZiRA06Y-LdunLtHN7XwBZgNG&index=37
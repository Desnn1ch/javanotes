Раньше мы создавали n потоков, они выполняли свою задачи и переходили в терминированное состояние. И мы не могли переиспользовать ранее созданные потоки. Это очевидно не оптимально, потому что создание потока само по себе дорого. Ну и никак не контролируется кол-во созданных потоков. Помимо этого чем больше потоков в нашей программе, тем медленнее будет выполняться наша программа из-за переключения между потоками.

Частично решаем проблемы вот таким подходом. Создаем `ExecutorService`, внутри которого будет `LinkedBlockingQueue` с тасками. В конструктор его передаем кол-во потоков, которые будут выполнять очередь тасок, таким образом мы сможем все потоки переиспользовать
![[Screenshot 2025-09-03 at 21.00.14.png]]

Код:
```java
public final class ExecutorService {
    private final BlockingQueue<Runnable> tasks = new LinkedBlockingQueue<>();

    public ExecutorService(final int threadCount) {
        startThreads(threadCount);
    }

    public void execute(final Runnable task) {
        try {
            tasks.put(task);
        } catch (final InterruptedException exception) {
            currentThread().interrupt();
        }
    }

    private void startThreads(final int count) {
        range(0, count)
            .mapToObj(i -> new Thread(new TaskExecutor()))
            .forEach(Thread::start);
    }

    private final class TaskExecutor implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    tasks.take().run();
                }
            } catch (final InterruptedException exception) {
                currentThread().interrupt();
            }
        }
    }
}
```

Но здесь есть минусы:

1. Мы не можем ограничить емкость нашей очереди (`OutOfMemoryError`)
2. Мы не можем использовать другие потокобезопасные коллекции внутри `ExecutorService`
3. Мы не можем создавать нужное кол-во потоков динамически
   Это плохо потому что тасок может быть много, потоков для них будет мало, либо наоборот, вобщем пон

## java.util.cuncurrent.ThreadPoolExecutor

| Param           | Type                     | Default value                    | Description                                                                                                                                                                    |
| --------------- | ------------------------ | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| corePoolSize    | int                      | NO                               | The number of threads to keep in the pool, even if they are idle (ничего не делают).                                                                                           |
| maximumPoolSize | int                      | NO                               | Максимальное число потоков, которые могут выполняться внутри `ThreadPoolExecutor`                                                                                              |
| keepAliveTime   | long                     | NO                               | Когда число потоков превышает corePoolSize, это максимальное время, в течение которого избыточные бездействующие потоки будут ожидать новых задач, прежде чем будут завершены. |
| unit            | TimeUnit                 | NO                               | The time unit for the keepAliveTime argument.                                                                                                                                  |
| workQueue       | BlockingQueue<Runnable>  | NO                               | The queue to use for holding tasks before they are executed.                                                                                                                   |
| threadFactory   | ThreadFactory            | Executors.defaultThreadFactory() | The factory to use when the executor creates a new thread.                                                                                                                     |
| handler         | RejectedExecutionHandler | new AbortPolicy()                | Обработчик, используемый в случае, когда выполнение блокируется из-за достижения границ потока и емкости очереди.                                                              |
Когда место в очереди заканчивается (можно в `BlockingQueue` в конструктор передать `capacity`), и когда у нас уже создалось corePoolSize потоков, тогда поток `main`  внутри экзекьютора попробует создать новый поток, и так будет до тех пор, пока кол-во потоков в экзекьюторе не будет >= maximumPoolSize

Когда у нас закончилось место в очереди и макс. кол-во потоков уже создалось - тогда в дело вступает handler, который по умолчанию просто выкинет `RejectedExecutionException`

Далее допустим у нас внутри ArrayBlockingQueue все задачи уже выполнились потоками и у нас как мы помним `main` наспавнил кучу потоков, кол-во которых явно больше чем corePoolSize. Все эти потоки стоят без дела keepAliveTime, поток терминируются. В экзекьюторе остается только corePoolSize потоков.

Когда же тогда экзекьютор закончит свое выполнение? Только после метода `shutdown()`, причем пока все таски не выполняться - экзекьютор будет работать, но каждая попытка положить что-то в экзекьютор будет обрабатываться handlerom, ну тобишь реджектиться.

Есть еще метод `shotdownNow()`, он у каждого из потоков вызовет `interrupt`

У экзекьютора есть еще вот такие статик методы. Можно например создать экзекьютор без ограничения по количеству потоков
![[Screenshot 2025-09-03 at 21.33.46.png]]

_Note_: эту хуйню можно создавать с try-with-resources, тоесть просто в блоке `try` без finally, тк он реализует паттерн autocloses. Там просто будет `shutdown()`.
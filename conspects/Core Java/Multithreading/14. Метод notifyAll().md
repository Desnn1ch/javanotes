Воспользуемся кодом прошлых готов так сказать:

В`main` у нас теперь 2 продьюссера и 1 консьюмер:
```java
package org.gerasic.notifyAll;  
  
import static java.util.Arrays.stream;  
  
public final class Main {  
    public static void main(final String... args) {  
        final int brokerMaxStoredMessage = 1;  
        final MessageBroker messageBroker = new MessageBroker(brokerMaxStoredMessage);  
  
        final MessageFactory messageFactory = new MessageFactory();  
  
        final Thread firstProducingThread = new Thread(new MessageProducingTask(messageBroker, messageFactory));  
        final Thread secondProducingThread = new Thread(new MessageProducingTask(messageBroker, messageFactory));  
  
        final Thread firstConsumingThread = new Thread(new MessageConsumingTask(messageBroker));  
  
        startThreads(firstProducingThread, secondProducingThread, firstConsumingThread);  
    }  
    private static void startThreads(final Thread... threads) {  
        stream(threads).forEach(Thread::start);  
    }}
```

В `MessageBroker` избавились от накруток всяких разных и теперь все по уму, проверяем в продьюссере что очередь не заполнена, в консьюмере, что очередь не пуста:
```java
package org.gerasic.notifyAll;  
  
import java.util.ArrayDeque;  
import java.util.Optional;  
import java.util.Queue;  
  
import static java.lang.System.out;  
  
public final class MessageBroker {  
  
    private static final String MESSAGE_OF_MESSAGE_IS_PRODUCED = "Message '%s' is produced\n";  
    private static final String TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED = "Message '%s' is consumed\n";  
    private final Queue<Message> messagesToBeConsumed;  
    private final int maxStoredMessages;  
  
    public MessageBroker(final int maxStoredMessages) {  
        this.messagesToBeConsumed = new ArrayDeque<>(maxStoredMessages);  
        this.maxStoredMessages = maxStoredMessages;  
    }  
    public synchronized void produce(final Message message) {  
        try {  
            while (messagesToBeConsumed.size() >= maxStoredMessages) {  
                wait();  
            }            messagesToBeConsumed.add(message);  
            out.printf(MESSAGE_OF_MESSAGE_IS_PRODUCED, message);  
            notify();  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
        }    }  
    public synchronized Optional<Message> consume() {  
        try {  
            while (messagesToBeConsumed.isEmpty()) {  
                wait();  
            }            Message msg = messagesToBeConsumed.poll();  
            out.printf(TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED, msg);  
            notify();  
            return Optional.of(msg);  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        }    
	}
}
```

Теперь все это дело запускаем, и спустя какое-то время ловим вот такое состояние:
![[Screenshot 2025-08-25 at 21.32.31.png]]

Все 3 потока спят. Как же так получилось? А все просто. Метод `notify()` на рандом уведомляет ждущие потоки. И после того как он закончил выполнение, он точно также как и все имеет право конкурировать за ресурс, и вполне себе может выиграть. Последовательность примерно такая.

- П1 положил элемент в очередь попутно заблокав всех.
- П2 перехватил монитор и вошел в режим ожидания
- П1 перехватил монитор и вошел в режим ожидания
- К1 забрал элемент, разбудил П1.
- К1 перехватил монитор снова и снова ждет
- П1 кладет элемент в брокер и блочится
- П2 перехватил монитор чтобы войти в режим ожидания
- П1 снова захватил монитор и также вошел в режим ожидания

Вобщем лучше чекнуть видео если не понятно: `https://www.youtube.com/watch?v=Vyx5PMSkwTI&list=PLqnlz-HutZiRA06Y-LdunLtHN7XwBZgNG&index=20`

### Что же нам делать? как бороться с такой ситуацией?

На помощь приходит конечно же новый метод `notifyAll()`, который в 100% ситуациях разбудит вообще нахуй всех.

```java
package org.gerasic.notifyAll;  
  
import java.util.ArrayDeque;  
import java.util.Optional;  
import java.util.Queue;  
  
import static java.lang.System.out;  
  
public final class MessageBroker {  
  
    private static final String MESSAGE_OF_MESSAGE_IS_PRODUCED = "Message '%s' is produced\n";  
    private static final String TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED = "Message '%s' is consumed\n";  
    private final Queue<Message> messagesToBeConsumed;  
    private final int maxStoredMessages;  
  
    public MessageBroker(final int maxStoredMessages) {  
        this.messagesToBeConsumed = new ArrayDeque<>(maxStoredMessages);  
        this.maxStoredMessages = maxStoredMessages;  
    }  
    public synchronized void produce(final Message message) {  
        try {  
            while (messagesToBeConsumed.size() >= maxStoredMessages) {  
                wait();  
            }            messagesToBeConsumed.add(message);  
            out.printf(MESSAGE_OF_MESSAGE_IS_PRODUCED, message);  
            notifyAll();  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
        }    }  
    public synchronized Optional<Message> consume() {  
        try {  
            while (messagesToBeConsumed.isEmpty()) {  
                wait();  
            }            Message msg = messagesToBeConsumed.poll();  
            out.printf(TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED, msg);  
            notifyAll();  
            return Optional.of(msg);  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        }    
	}
}
```
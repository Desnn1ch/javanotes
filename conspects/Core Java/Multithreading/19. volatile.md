Представим вот такую схему, у каждого ядра есть cache, где они хранят наиболее часто используемые инструкции, чтобы ускорить доступ к ним, т.к. извлечение данных из этих кешей сильно быстрее чем из основной памяти
![[Screenshot 2025-08-26 at 21.11.06.png]]

Допустим thread-printer читает очень много раз boolean shouldPrint из основной памяти и читает его пока оно равно true. Тогда CPU 1 это закеширует и thread-printer будет читать какое-то время из кеша. А thread-manager записывает в shouldPrint false. И получается картина, когда у нас будут неконсистентные данные какое-то время:
![[Screenshot 2025-08-26 at 21.14.45.png]]

Для избежания такой ситуации и нужен `volatile`. Он буквально говорит потокам читать все не из кеша, а из основной памяти.

_Note_: очевидно, что если бы 2 потока работали внутри одного ядра процессора, то `volatile` был бы не нужен, потому что thread-manager изменил бы shouldPrint внутри кеша.

Вобщем короче если это критично - юзаем, если нет - не юзаем.
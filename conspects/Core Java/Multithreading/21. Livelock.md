Это сбой, при котором все потоки, хоть и не будут находиться в состоянии `BLOCKED`, как в случае `Deadlock`-a, но они все же не смогут продвигаться в перед тк всегда будут пытаться выполнить операцию, которая будет безуспешной

`Livelock` - это когда два потока уступают друг другу до бесконечности. Это как `Deadlock`, только наоборот, вот аналогия:
![[Screenshot 2025-08-27 at 14.11.27.png]]

Вот так можно словить его:
`Task`:
```java
import java.util.concurrent.locks.Lock;

import static java.lang.System.out;
import static java.lang.Thread.currentThread;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

public final class Task implements Runnable {

    private static final String MESSAGE_TEMPLATE_TRY_ACQUIRE_LOCK =
            "Thread '%s' is trying to acquire lock '%s'\n";
    private static final String MESSAGE_TEMPLATE_SUCCESS_ACQUIRE_LOCK =
            "Thread '%s' acquired lock '%s'\n";
    private static final String MESSAGE_TEMPLATE_RELEASE_LOCK =
            "Thread '%s' released lock '%s'\n";

    private static final String NAME_FIRST_LOCK = "firstLock";
    private static final String NAME_SECOND_LOCK = "secondLock";

    private final Lock firstLock;
    private final Lock secondLock;

    public Task(Lock firstLock, Lock secondLock) {
        this.firstLock = firstLock;
        this.secondLock = secondLock;
    }

    @Override
    public void run() {
        final String currentThreadName = currentThread().getName();
        out.printf(
		        MESSAGE_TEMPLATE_TRY_ACQUIRE_LOCK, 
		        currentThreadName, 
		        NAME_FIRST_LOCK);
        this.firstLock.lock();
		try {
		    out.printf(
				    MESSAGE_TEMPLATE_SUCCESS_ACQUIRE_LOCK, 
				    currentThreadName, 
				    NAME_FIRST_LOCK);
		    MILLISECONDS.sleep(50);
		    while (!this.tryAcquireSecondLock()) {
		        MILLISECONDS.sleep(50);
		        this.firstLock.unlock();
		        out.printf(
				        MESSAGE_TEMPLATE_RELEASE_LOCK, 
				        currentThreadName, 
				        NAME_FIRST_LOCK);
		        MILLISECONDS.sleep(50);
		        out.printf(
				        MESSAGE_TEMPLATE_TRY_ACQUIRE_LOCK, 
				        currentThreadName, 
				        NAME_FIRST_LOCK);
		        this.firstLock.lock();
		        out.printf(
				        MESSAGE_TEMPLATE_SUCCESS_ACQUIRE_LOCK, 
				        currentThreadName,
				        NAME_FIRST_LOCK)
		        MILLISECONDS.sleep(50);
		    }
		    try {
		        out.printf(
				        MESSAGE_TEMPLATE_SUCCESS_ACQUIRE_LOCK, 
				        currentThreadName, 
				        NAME_SECOND_LOCK);
		    } finally {
		        this.secondLock.unlock();
		        out.printf(
				        MESSAGE_TEMPLATE_RELEASE_LOCK, 
				        currentThreadName, 
				        NAME_SECOND_LOCK);
		    }
		} catch (final InterruptedException interruptedException) {
		    Thread.currentThread().interrupt();
		} finally {
		    this.firstLock.unlock();
		    out.printf(
				    MESSAGE_TEMPLATE_RELEASE_LOCK, 
				    currentThreadName, 
				    NAME_FIRST_LOCK);
		}
    }
}
```

`main`:
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public final class Runner {
    public static void main(final String... args) {
        final Lock firstGivenLock = new ReentrantLock();
        final Lock secondGivenLock = new ReentrantLock();

        final Thread firstGivenThread =
                new Thread(new Task(firstGivenLock, secondGivenLock));
        final Thread secondGivenThread =
                new Thread(new Task(secondGivenLock, firstGivenLock));

        firstGivenThread.start();
        secondGivenThread.start();
    }
}
```

Вывод ожидаемый, они просто будут бесконечно уступать друг другу.
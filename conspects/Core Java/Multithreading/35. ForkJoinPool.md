наконец-то 

Экземпляр `ForkJoinPool` во многом напоминает `ThreadPoolExecutor`. Он также содержит очередь задач и пул потоков.
![[Screenshot 2025-09-03 at 21.57.22.png]]

Но, как мы видим на пикче, каждая таска разбивается на подзадачи. Причем делается это максимальное кол-во раз. Идеалогически это похоже на mergeSort.

В форк можно передать `Callable` и `Runnable`, но в таком случае он не будет разделяться, а будет выполняться тупо 1 в 1 как в экзекьюторе.

Чтобы все работало как задумано, нужно передавать экземпляр класса, реализующего `ForkJoinTask`, их есть 2 типа, первый тип возвращаемое значение, второй невозвращаемое. Можно провести аналогию с `Callable` и `Runnable` соответственно. В этих классах надо заоверрайдить метод `compute()`. 

![[Screenshot 2025-09-03 at 22.01.35.png]]

Вот так это все может выглядеть:
```java
@Override
protected Object compute() {
    if (isSplittable()) {
        final Subtasks subtasks = splittingService.split(this);
        subtasks.getLeft().fork();
        subtasks.getRight().fork();

        final Object leftSubtaskResult = subtasks.getLeft().join();
        final Object rightSubtaskResult = subtasks.getRight().join();

        return merge(leftSubtaskResult, rightSubtaskResult);
    } else {
        return execute();
    }
}
```

#### Пошагово

1. **Проверка условия**
    
    `if (isSplittable())`
    
    Смотрим, можно ли текущую задачу разделить на подзадачи.  
    (Например: массив слишком большой → его можно разбить на две половины.)
    
2. **Разделение задачи**
    
    `final Subtasks subtasks = splittingService.split(this);`
    
    Текущая задача делится на 2 подзадачи: `getLeft()` и `getRight()`.
    
3. **Форкаем (запускаем) подзадачи**
    
    `subtasks.getLeft().fork(); subtasks.getRight().fork();`
    
    Каждая подзадача отправляется на выполнение в **ForkJoinPool** (асинхронно, возможно на других потоках).
    
4. **Ждём выполнения подзадач**
    
    `final Object leftSubtaskResult = subtasks.getLeft().join(); final Object rightSubtaskResult = subtasks.getRight().join();`
    
    `join()` блокирует текущую задачу, пока подзадача не завершится, и возвращает результат.
    
5. **Объединение результатов**
    
    `return merge(leftSubtaskResult, rightSubtaskResult);`
    
    Результаты двух подзадач объединяются (например: сумма чисел, конкатенация строк, объединение коллекций).
    
6. **Если нельзя разделить**
    
    `else {     return execute(); }`
    
    Если задача слишком маленькая, или её нельзя разбить → она выполняется напрямую.
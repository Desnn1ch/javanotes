```java
import java.util.concurrent.TimeUnit;

public final class Runner {

    private static final String MESSAGE_REQUEST_WAS_SENT = "\nRequest was sent.";
    private static final int DURATION_IN_SECONDS_DELIVERING_RESPONSE = 1;
    private static final String MESSAGE_RESPONSE_WAS_RECEIVED = "Response was received.";
    private static final String MESSAGE_SERVER_WAS_STOPPED = "Server was stopped.";
    private static final int TIME_WAITING_IN_SECONDS_TO_START_STOPPING_THREAD = 5;

    public static void main(final String... args) throws InterruptedException {
        // Поток «коммуникации»: шлёт запросы, ждёт ответы в бесконечном цикле
        final Thread communicatingThread = new Thread(() -> {
            try {
                while (!communicatingThread.isInterrupted()) {
                    doRequest();
                }
            } catch (final InterruptedException ignored) {
                System.out.println(MESSAGE_SERVER_WAS_STOPPED);
                Thread.currentThread().interrupt();
            }
        }, "communicating-thread");

        communicatingThread.start();

        // «Стоп-поток»: через 5 секунд останавливает communicatingThread
        final Thread stoppingThread = new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(TIME_WAITING_IN_SECONDS_TO_START_STOPPING_THREAD);
                communicatingThread.interrupt();
            } catch (InterruptedException ignored) {
                Thread.currentThread().interrupt();
            }
        }, "stopping-thread");

        stoppingThread.start();

        stoppingThread.join();
        communicatingThread.join();
        System.out.println("main finished.");
    }

    /** Имитация запроса/ответа. */
    private static void doRequest() throws InterruptedException {
        System.out.println(MESSAGE_REQUEST_WAS_SENT);
        TimeUnit.SECONDS.sleep(DURATION_IN_SECONDS_DELIVERING_RESPONSE); // «доставка» ответа
        System.out.println(MESSAGE_RESPONSE_WAS_RECEIVED);
    }
}

```

#### Что здесь происходит коротко

- Есть поток, который бесконечно отправляет запросы (куда-то нам неважно куда)
- Есть поток, который хочет остановить предидущий
- Для этого мы используем усовершенствованную версию `Thread::stop `- `Thread::interrupt`

#### Отличие `Thread::stop` и `Thread::interrupt`

|Критерий|`Thread.stop()` ❌ (устаревший)|`Thread.interrupt()` ✅ (рекомендуемый)|
|---|---|---|
|**Способ остановки**|Принудительно завершает поток **в любой точке исполнения**|Посылает потоку «сигнал», что его хотят прервать|
|**Безопасность данных**|❌ Может оборвать выполнение в середине критической секции → данные повреждены|✅ Поток сам решает, когда и как завершиться, может корректно освободить ресурсы|
|**Исключения**|Может оборвать выполнение без `finally` → ресурсы утекут|Методы (`sleep`, `wait`, `join`) выбрасывают `InterruptedException`, который можно обработать|
|**Состояние потока**|Завершается мгновенно, неважно, где находился|Поток остаётся в `RUNNABLE` или выбрасывает `InterruptedException`, пока сам не выйдет|
|**Использование сегодня**|Deprecated (с JDK 1.2), использовать **не рекомендуется**|Стандартный способ управления жизненным циклом потока|
|**Пример**|`thread.stop();` (⚠️ небезопасно)|`thread.interrupt();` + `while (!Thread.currentThread().isInterrupted()) { ... }`|
|**Контроль**|❌ Поток не контролирует завершение|✅ Поток сам контролирует корректное завершение|

---

#### Нюанс

- Не всегда можно проверить поток на состояние прерванности т.к. поток может быть заблокирован например операцией запроса на сервер или в результате метода `sleep()`
- Здесь приходит на помощь `InterruptedException`. Когда метод `Thread::interrupt` вызывается для потока исполнения, который заблокирован, блокирующий вызов прерывается исключением типа `InterruptedException` 
##### НО
Это все еще не гарантирует, что поток будет остановлен, пример:
```java
final Thread communicatingThread = new Thread(() -> {
            while (true) {
                try {
                    doRequest();
                } catch (final InterruptedException interruptedException) {
                    out.println(MESSAGE_THREAD_WAS_INTERRUPTED);
                }
            }
        }, "communicating-thread");

```
Поток выкинет исключение, но исключение отловилось и поток продолжил свою работу
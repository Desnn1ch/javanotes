Всего 6 состояний:
1. New
2. Runnable
3. Blocked
4. Waiting
5. TimedWaiting (временно ожидающий)
6. Terminated (завершенный)

### 1. **NEW (Новый)**

- Поток создан (`new Thread(...)`), но ещё **не запущен** (`.start()` не вызывался).
- В этом состоянии у него нет системных ресурсов ОС (стек, планировщик ещё не знает о нём).

Пример:
```java
Thread t = new Thread();
System.out.println(t.getState()); // NEW
```
---
### 2. **RUNNABLE (Готов к выполнению / выполняющийся)**

- После вызова `thread.start()` поток переходит в **RUNNABLE**.
- Но это **не значит, что он прямо сейчас выполняется** – он лишь готов к запуску.
- Планировщик ОС решает, когда реально дать ему CPU.
- Поэтому `RUNNABLE` = "в очереди на выполнение" или "выполняется".
---
### 3. **BLOCKED (Заблокированный)**

- Поток пытается войти в **synchronized-блок/метод**, но монитор занят другим потоком.
- Он ждёт освобождения монитора → поэтому находится в **BLOCKED**.
- Как только монитор освободится → вернётся в **RUNNABLE**.
---

### 4. **WAITING (Ожидание)**

- Поток ждёт **бессрочно**, пока другой поток не "разбудит" его (`notify()` или `notifyAll()`).
- Сюда попадают при вызове:
    - `Object.wait()` без таймаута
    - `Thread.join()` без таймаута

Пример:
```java
synchronized(lock) {
    lock.wait(); // поток теперь WAITING
}
```
---

### 5. **TIMED_WAITING (Временно ожидающий)**

- Почти то же самое, что `WAITING`, но с ограничением по времени.
- Поток автоматически вернётся в **RUNNABLE**, если время истечёт.
- Методы, которые сюда приводят:
    - `Thread.sleep(ms)`
    - `Object.wait(ms)`
    - `Thread.join(ms)`
    - `LockSupport.parkNanos()` / `parkUntil()`

---

### 6. **TERMINATED (Завершённый)**

- Поток отработал метод `run()` до конца.
- Его уже нельзя перезапустить (`.start()` кинет `IllegalThreadStateException`).
- Состояние фиксируется навсегда.

### Как можно получить состояние потока?

```java
import static java.lang.System.out;
import static java.lang.String.format;
import static java.lang.Thread.currentThread;

public final class Runner {
    private static final String MESSAGE_TEMPLATE_THREAD_STATE = "%s : %s%n";

    public static void main(final String... args) throws InterruptedException {
        final Thread thread = new Thread(() -> {
            // внутри run() поток выведет своё состояние
            showThreadState(currentThread());
        }, "MyThread");

        // Поток ещё не запущен → NEW
        showThreadState(thread);

        // Запускаем → теперь RUNNABLE
        thread.start();

        // Немного ждём, чтобы поток успел выполниться (main TimedWaiting)
        Thread.sleep(100);

        // После завершения → TERMINATED
        showThreadState(thread);
    }

    private static void showThreadState(final Thread thread) {
        out.printf(MESSAGE_TEMPLATE_THREAD_STATE,
                thread.getName(), thread.getState());
    }
}
```

_Note:_ когда два потока выполняются на одном ядре, они оба стоят как RUNNABLE, хотя по факту существует небольшая пауза у каждого, когда процессор квантуется. Вобщем стейт потока не учитывает ни коим образом квантование

_Note:_ **main всегда дождётся завершения дочернего потока** (через `join`), даже если тот упал с исключением. Само исключение будет напечатано в стандартный поток ошибок (stderr), но оно **не убивает главный поток**, пример:

```java
import static java.lang.System.out;
import static java.lang.String.format;

public final class Runner {
    private static final String MESSAGE_TEMPLATE_THREAD_STATE = "%s : %s%n";

    public static void main(final String... args) throws InterruptedException {
        final Thread thread = new Thread(() -> {
            // Поток выбросит исключение и завершится с ошибкой
            throw new RuntimeException("Ошибка в потоке!");
        }, "MyThread");

        thread.start();
        thread.join();    // main ждёт завершения этого потока

        showThreadState(thread);
        out.println("main закончил работу!");
    }

    private static void showThreadState(final Thread thread) {
        out.printf(MESSAGE_TEMPLATE_THREAD_STATE,
                thread.getName(), thread.getState());
    }
}
```
Вывод:
```java
Exception in thread "MyThread" java.lang.RuntimeException: Ошибка в потоке!
    at Runner.lambda$main$0(Runner.java:10)
    at java.base/java.lang.Thread.run(Thread.java:833)
MyThread : TERMINATED

main закончил работу!
```
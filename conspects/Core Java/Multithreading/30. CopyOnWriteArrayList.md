`CopyOnWriteArrayList<E>` — это потокобезопасный список (реализация `List`), где **все операции записи делают копию массива**. 

Вы наверное спросите, а нахуя на каждую операцию записи копировать весь массив? А именно потому, что оригинальная ссылка на массив внутри нашей коллекции подменяется в момент операции записи, тем самым итераторы ходят по старой ссылке как по снапшоту.

- **Чтение (`get`, итерация, size`)** — идёт без блокировок, просто из текущего массива.
- **Модификация (`add`, `set`, `remove`)** — создаёт новый массив, копирует туда элементы + вносит изменения, и только потом заменяет старый массив на новый. (да, реально копирует весь массив, потом подменяет ссылку)

## Как это работает внутри

У `CopyOnWriteArrayList` есть одно поле: `private transient volatile Object[] array;`

1. **Чтение** (`get(i)`):  
    - Просто берёт `array[i]`.  
    - Благодаря `volatile` читатель всегда видит актуальную ссылку на массив.
    
2. **Добавление** (`add(e)`) (как и все операции записи делает ссылку):
    - Берёт текущий массив.
    - Создаёт новый массив размером +1.
    - Копирует старый в новый.
    - Добавляет элемент.
    - Подменяет ссылку `array` на новый массив.
    
3. **Итерация** (`iterator()`):  
    - Возвращает **снапшот массива на момент создания итератора**.
    - То есть если в другой нити добавили/удалили элемент, твой итератор этого уже не увидит.
    - Зато он никогда не упадёт с `ConcurrentModificationException`.

## Особенности

- ✅ Потокобезопасен без внешней синхронизации.
- ✅ Итерация очень быстрая и без блокировок.
- ✅ Идеален, если операций чтения **много**, а операций записи **мало**.
- ❌ Каждая модификация требует копирования всего массива → дорого при больших размерах и частых изменениях.
- ❌ Итератор не "живой" — он смотрит только на срез (snapshot), изменения после его создания не видны.

## Где применяют

Таблицы слушателей (`listeners` в `Swing`, `Netty` и т. п.), где:
- 99% времени → читаем список (уведомляем слушателей),
- 1% времени → регистрируем/удаляем слушателя.    
- Конфигурации, которые редко меняются, но часто читаются.

### Сравнение

|Коллекция|Потокобезопасность|Итератор|Стоимость записи|
|---|---|---|---|
|`ArrayList`|❌|fail-fast|O(1) амортиз.|
|`Vector`|✅ (синхр. весь)|fail-fast|O(1) амортиз.|
|`CopyOnWriteArrayList`|✅ (через копии)|snapshot|O(n)|



_Note_: Есть еще `CopyOnWriteArraySet` - он в себе тупо содержит `CopyOnWriteArrayList` и полностью соответствует его принципам.
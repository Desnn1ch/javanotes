Допустим надо реализовать генерацию некоторого количества чисел, а затем найти сумму этих чисел. Мы захотели каждый `generateInt` проапгрейдить многопоточкой. При этом создавать на каждый `generateInt` новый поток неэффективно.

Воспользуемся экзекьютором. Но каким тогда образом можно вернуть оттуда сгенерированное число? Ведь дефолтная таска, которую мы передаем в экзекьютор (`Runnable`) представляет из себя только один метод `void Run()`, который ничего не возвращает. И тут нам поможет `Callable<V>`

```java
try (final ExecutorService executorService = newFixedThreadPool(3)) {
    final Future<Integer> future = 
		    executorService.submit(new NumberGeneratingTask());
    final Integer number = future.get();
    out.println(number);
}
```

Здесь мы создаем пулл потоков. Потом пул передаётся задача `NumberGeneratingTask` (реализует `Callable<Integer>`). Метод `submit()` возвращает `Future<Integer>` — объект, через который можно получить результат выполнения.

Вызов `future.get()` блокирует текущий поток до тех пор, пока задача не завершится.  
После выполнения задачи возвращается результат (в данном случае — число `Integer`).

Есть еще вот такие методы у `Future<T>`:

| Метод                                           | Возвращаемый тип | Что делает                                                                                                                                                                 |
| ----------------------------------------------- | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `boolean cancel(boolean mayInterruptIfRunning)` | `boolean`        | Пытается отменить выполнение задачи. Если `mayInterruptIfRunning = true`, то задача может быть прервана, если уже запущена. Возвращает `true`, если отмена прошла успешно. |
| `Throwable exceptionNow()` _(default)_          | `Throwable`      | Возвращает исключение, с которым завершилась задача, если оно есть (Java 19+).                                                                                             |
| `V get()`                                       | `V`              | Блокирует текущий поток и ждёт завершения задачи. После завершения возвращает результат или выбрасывает исключение.                                                        |
| `V get(long timeout, TimeUnit unit)`            | `V`              | Ждёт завершения задачи ограниченное время. Если задача не успела завершиться — выбрасывает `TimeoutException`.                                                             |
| `boolean isCancelled()`                         | `boolean`        | Возвращает `true`, если задача была отменена до её завершения.                                                                                                             |
| `boolean isDone()`                              | `boolean`        | Возвращает `true`, если задача завершена (успешно, с ошибкой или отменена).                                                                                                |
Но вообще говоря, непонятно, как мы запихали в нашу очередь задач интерфейс `Callable`, ведь он не реализует интерфейс `Runnable`. А вот как:
- Callable в методе экзекьютора `submit ` оборачивается в `RunnableFuture`
- Выполняется как обычная таска
- И возвращается `FutureTask`, который в себе уже имеет посчитанное значение
![[Screenshot 2025-09-03 at 21.50.32.png]]
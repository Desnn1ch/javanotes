
### Устройство памяти

**Native Memory** — вся доступная системная память.

Память в Java состоит из нескольких областей:
- **Heap (куча)** - часть native memory, выделенная для хранения объектов. Является общей для всех потоков приложения. Размер этой области памяти настраивается с помощью параметра -Xms (минимальный размер) и -Xmx (максимальный размер).
- **Stack (стек)** - часть памяти для хранения локальных переменных и стека вызовов метода. У каждого потока свой стек. 
- **Metaspace (метаданные)** - тут хранятся метаданные классов и статические переменные. Верхний предел объема памяти, используемой для metaspace, можно настроить с помощью флага MaxMetaspaceSize.
- **PermGen** (Permanent Generation, постоянное поколение) присутствовало до Java 7. Начиная с Java 8 ему на смену пришла область Metaspace.
- **CodeCache (кэш кода)** — JIT-компилятор компилирует часто исполняемый код, преобразует его в нативный машинный код и кеширует для более быстрого выполнения. Это тоже часть native memory.

##### Теперь подробнее про кучу

Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).

**Heap:**
- **Young Generation** 
	- **Eden** - тут находится объекты сразу после создания. Примерно 75% от всего Young Generation. Это первичная цель для Minor GC 
	- **S0, S1** - области, куда перемещаются "выжившие" после GC объекты. Их еще обозначают S0 (From Space) и S1 (To Space).  Два идентичных по размеру пространства, которые используются как источник и приемник при копировании во время Minor GC.
		**Принцип работы**:
		1. **До GC**: Одно пространство содержит выжившие объекты
		2. **Во время GC**: Живые объекты копируются в другое пространство
		3. **После GC**: Роли меняются
-  **Old Generation**
	- Область для long-lived объектов, которые пережили несколько сборок мусора в Young Generation.
	- **Характеристики**:
		- Большой размер (обычно 2/3 от всей кучи)
		- Редкие, но медленные сборки мусора (Major GC)
		- Объекты живут долго или постоянно
		- Более сложная структура памяти

### Сборка мусора

Мусором считается объект, который больше не может быть достигнут по ссылке из какого-либо объекта. Поскольку такие объекты больше не используются в приложении, то их можно удалить из памяти.

Сборка мусора — это процесс автоматического управления памятью. Освобождение памяти (путем очистки мусора) выполняется автоматически специальным компонентом JVM — сборщиком мусора (Garbage Collector, GC).

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

1. **Mark (маркировка)**. На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
    
2. **Sweep (очистка)**. На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
    
3. **Compact (уплотнение)**. Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

#### Что такое Stop the World?

Когда запускается этап mark, работа приложения останавливается. После завершения mark приложение возобновляет свою работу. Любая сборка мусора — это "Stop the World".

#### Что такое гипотеза о поколениях?

Как уже упоминалось ранее, для оптимизации этапов mark и sweep используются поколения. Гипотеза о поколениях говорит о следующем:

1. Большинство объектов живут недолго.
    
2. Если объект выживает, то он, скорее всего, будет жить вечно.
    
3. Этапы mark и sweep занимают меньше времени при большом количестве мусора. То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много мертвых объектов.

Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:
![Сборка мусора поколениями](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d8b/a3f/a48/d8ba3fa48616085ab2b5d79dfde43d71.png "Сборка мусора поколениями")

Сборка мусора поколениями

1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
    
2. Когда область Eden заполняется, происходит **минорная сборка мусора (Minor GC)**. Minor GC — это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).
    
3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
    
4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
    
5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
    
6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
    
7. Major GC. При **Major GC** этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.

#### Преимущества использования поколений

Minor GC происходит в меньшей части кучи (~ 2/3 от кучи). Этап маркировки эффективен, потому что область небольшая и состоит в основном из мертвых объектов.

#### Недостатки использования поколений

В каждый момент времени одно из пространств Survivor (S0 или S1) пустое и не используется.

### Типы сборщиков мусора

1. **Serial GC**
	Однопоточный сборщик, подходящий для небольших приложений.
	**Алгоритм:**
	- Young Generation: Copying
		- Живые объекты копируются из Eden и одного Survivor (S0) в другой Survivor (S1). Eden и S0 очищаются полностью.
		- Объекты, пережившие несколько циклов (по умолчанию 15, настраивается через -XX:MaxTenuringThreshold), перемещаются в Old Generation
	- Old Generation: Mark-and-Sweep-Compact
		- Маркировка живых объектов от GC Roots.
		- Очистка недостижимых объектов. 
		- Компактизация для устранения фрагментации
	**Когда использовать?**
	- Клиентские приложения с малой кучей (<512 МБ).
	- Одноядерные системы.
2. **Parallel GC**
	Многопоточный сборщик, оптимизированный для пропускной способности.
	**Алгоритм:**
	- Young Generation: Copying (параллельное выполнение)
		- Аналогично Serial GC, но использует несколько потоков для копирования объектов.
	- Old Generation: Mark-and-Sweep-Compact (параллельное выполнение)
		- Маркировка, очистка и компактизация выполняются в несколько потоков
	**Как определяет, кого удалять?**
	-  То же, что в Serial GC, но быстрее благодаря параллельной работе.
	
	**Когда использовать?**
	- Серверные приложения, где важна пропускная способность, а паузы до 1–2 секунд допустимы.
	- Кучи до 4 ГБ.
3. **CMS (Concurrent Mark-Sweep)**
	Сборщик с низкими задержками, работающий конкурентно.
	**Алгоритм:**
	- Young Generation: Copying (STW)
		- Аналогично Serial и Parallel GC. 
	- Old Generation: Concurrent Mark-Sweep
		- Initial Mark (STW): Короткая пауза для маркировки GC Roots
		- Concurrent Mark: Маркировка остальных объектов параллельно
		- Remark (STW): Исправление ошибок
		- Concurrent Sweep: Очистка памяти параллельно
	**Как определяет, кого удалять?**
	- В Young Generation: Копирует достижимые объекты.
	- В Old Generation: Помечает живые объекты, очищает недостижимые без компактизации. 
	**Проблемы:**
	- Фрагментация памяти (решается периодической компактизацией с STW). 
	- Возможен "concurrent mode failure", если Old Generation заполняется быстрее, чем очищается.
	**Когда использовать?**
	- Приложения с задержками <500 мс (например, веб-сервисы).
	- Устарел, заменён G1.
4. **G1 (Garbage-First)**
	Региональный сборщик для больших куч и низких задержек
	**Алгоритм:**
	- Young Generation: Copying
		- Копирует живые объекты между регионами Young Generation
	- Old Generation: Concurrent Mark-Sweep + Copying
		- Делит heap на регионы (1–32 МБ)
		- Выполняет конкурентную маркировку для определения живых объектов.
		- Очищает регионы с наибольшим количеством мусора (Garbage-First)
		- Перемещает живые объекты из "грязных" регионов в новые (копирование).
	**Особенности:** 
	- Предсказуемые паузы через -XX:MaxGCPauseMillis.
	- Компактизация выполняется постепенно, минимизируя фрагментацию.
	**Когда использовать?**:
	- Серверные приложения с кучей >4 ГБ
	- Баланс задержек и пропускной способности
5. **ZGC (Z Garbage Collector)**
	Сборщик с ультранизкими задержками (<1 мс)
	**Алгоритм:**
	- Concurrent Mark-Sweep + Concurrent Compaction
		- Использует цветные указатели для отслеживания ссылок
		- <img width="971" height="192" alt="image" src="https://github.com/user-attachments/assets/481d2454-68bb-4b64-9c38-7d84311b04c0" />
		- Marked0 (0001) и Marked1 (0010) — используются для пометки указателей на разных фазах сборки. 
		- Remapped (0100) — указатель помечается этим битом в случае, если адрес в указателе является окончательным и не должен модифицироваться в рамках текущего цикла сборки. Finalizable (1000) — этим битом помечаются объекты, достижимые только из финализатора
		- Конкурентно помечает живые объекты
		- Конкурентно перемещает объекты для компактизации
		- Использует барьер. Барьер — это просто функция, которая принимает указатель на объект в памяти, анализирует цвет этого указателя, в зависимости от цвета выполняет какие-либо действия с этим указателем или даже с самим объектом, на который он ссылается, после чего возвращает актуальное значение указателя, которое необходимо использовать для доступа к объекту
	**Особенности:**
	- Поддерживает кучи до терабайт
	- Высокие накладные расходы на CPU
	**Когда использовать?**
	- Реал-тайм системы, финтех.
6. **Shenandoah GC**
	Сборщик с низкими задержками, аналог ZGC
	**Алгоритм:**
	- Concurrent Mark-Sweep + Concurrent Compaction
		- Использует барьеры чтения/записи для синхронизации
		- Конкурентно маркирует и перемещает объекты
		- Указатель перенаправления Брукса
	**Когда использовать?**
	- Приложения с высокими требованиями к задержкам
7. **Epsilon GC**
	Сборщик, который не выполняет сборку мусора.
	**Когда использовать?** 
	- Тестирование или приложения с коротким временем жизни.

### Ссылки

Java предоставляет четыре типа ссылок, которые влияют на то, как объекты обрабатываются сборщиком мусора: Strong, Soft, Weak и Phantom. Они определены в пакете java.lang.ref.

1. **Strong Reference (Сильная ссылка)**
	- **Описание:** Обычная ссылка, создаваемая при присваивании объекта переменной
	- **Поведение при GC:** 
		- Объект с сильной ссылкой никогда не собирается, пока ссылка активна.
		- Если объект достижим только через сильные ссылки, он остаётся в памяти.
	- **Применение:** 
		- Стандартный способ работы с объектами.
	- **Влияние на GC:** 
		- Может привести к утечкам памяти, если ссылки не очищаются (например, в кэшах).
2. **Soft Reference (Мягкая ссылка)**
	- **Описание:** Ссылка, создаваемая через SoftReference. Объект может быть собран, если JVM испытывает нехватку памяти.
	- **Поведение при GC:** 
		- Объект удаляется, если нет сильных ссылок и память заканчивается. 
		- GC старается сохранить такие объекты как можно дольше.
	- **Применение: **
		- Кэши, чувствительные к памяти (например, кэш изображений).
	- **Влияние на GC:** 
		- Помогает избежать OutOfMemoryError, позволяя GC освобождать память по необходимости. 
3. **Weak Reference (Слабая ссылка)** 
	- **Описание:** Ссылка, создаваемая через WeakReference. Объект собирается при следующем цикле GC, если нет сильных или мягких ссылок. 
	- **Поведение при GC:** 
		- Объект удаляется при любом цикле GC, если достижим только через слабые ссылки. 
	- **Применение:** 
		- Кэши, где объекты могут быть легко пересозданы. 
		- Хранение метаданных (например, в WeakHashMap). 
	- **Влияние на GC:**
		- Ускоряет освобождение памяти для объектов, которые не критичны. 
4. **Phantom Reference (Фантомная ссылка)** 
	- **Описание:** Ссылка, создаваемая через PhantomReference. Используется для отслеживания, когда объект становится готовым к финализации.
	- **Поведение при GC:** 
		- Объект собирается, как только становится недостижимым. 
		- Фантомная ссылка добавляется в ReferenceQueue, когда объект готов к удалению.
	- **Применение:** 
		- Управление ресурсами перед финализацией (например, закрытие файлов).
		- Отслеживание удаления объектов. 
	- **Влияние на GC:** 
		- Не влияет на сборку, но позволяет выполнять действия перед удалением объекта.
5. **ReferenceQueue** 
	- Все слабые, мягкие и фантомные ссылки могут быть связаны с ReferenceQueue.
	- Когда GC определяет, что объект готов к сборке, соответствующая ссылка добавляется в очередь.
	- Это полезно для выполнения очистки (cleanup) после удаления объекта.
6. **WeakHashMap** 
	- WeakHashMap использует слабые ссылки для ключей. 
	- Если ключ становится недостижимым, запись автоматически удаляется из карты.

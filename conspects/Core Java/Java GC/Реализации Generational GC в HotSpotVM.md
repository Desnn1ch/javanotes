_Note:_ **HotSpotVM** (полное название: **HotSpot Virtual Machine**) — это основная и самая популярная реализация **Java Virtual Machine (JVM)**, которая ставится вместе с JDK/JRE от Oracle и OpenJDK.

## Serial GC

Однопоточный сборщик, подходящий для небольших приложений. Использует stw.

**Алгоритм:**

1. Young Generation: Copying
	- Живые объекты копируются из Eden и одного Survivor (S0) в другой Survivor (S1). Eden и S0 очищаются полностью.
	- Объекты, пережившие несколько циклов (по умолчанию 15, настраивается через -XX:MaxTenuringThreshold), перемещаются в Old Generation

2. Old Generation: Mark-and-Sweep-Compact
	- Маркировка живых объектов от GC Roots.
	- Очистка недостижимых объектов. 
	- Компактизация для устранения фрагментации

**Когда использовать?**
- Клиентские приложения с малой кучей (<512 МБ).
- Одноядерные системы.

## Parallel GC

Многопоточный сборщик, оптимизированный для пропускной способности. Использует stop-the-world.

**Алгоритм:**

1. Young Generation: Copying (параллельное выполнение)
	- Аналогично Serial GC, но использует несколько потоков для копирования объектов.
  
2. Old Generation: Mark-and-Sweep-Compact (параллельное выполнение)
	- Маркировка, очистка и компактизация выполняются в несколько потоков

**Как определяет, кого удалять?**
-  То же, что в Serial GC, но быстрее благодаря параллельной работе.

**Когда использовать?**
- Серверные приложения, где важна пропускная способность, а паузы до 1–2 секунд допустимы.
- Кучи до 4 ГБ.

Для приложений со средними и большими наборами данных, которые выполняются на многопроцессорном или многопоточном оборудовании. Используется по умолчанию.

Несколько потоков предназначаются для minor GC. Один поток для major GC.

## CMS GC

Сборщик с низкими задержками, работающий конкурентно.

**Алгоритм:**

1. Young Generation: Copying (STW)
	- Аналогично Serial и Parallel GC. 

2. Old Generation: Concurrent Mark-Sweep
	- Initial Mark (STW): Короткая пауза для маркировки GC Roots
	- Concurrent Mark: Маркировка остальных объектов параллельно
	- Remark (STW): Исправление ошибок
	- Concurrent Sweep: Очистка памяти параллельно

**Как определяет, кого удалять?**
- В Young Generation: Копирует достижимые объекты.
- В Old Generation: Помечает живые объекты, очищает недостижимые без компактизации. 

**Проблемы:**
- Фрагментация памяти (решается периодической компактизацией с STW). 
- Возможен "concurrent mode failure", если Old Generation заполняется быстрее, чем очищается.

**Когда использовать?**
- Приложения с задержками <500 мс (например, веб-сервисы).
- Устарел, заменён G1.

Для малой сборки мусора используется несколько потоков, как и в параллельном сборщике. основная сборка мусора многопоточна, но CMS работает одновременно с процессами приложений, чтобы как можно сильнее уменьшить stop-the-world.

Из-за этого требует больше ресурсов процесса.

Не используется уплотнение.

## G1 GC

Garbage First GC (Мусор — первым).

типа замены CMS, но для больших куч. параллелен и многопоточен, как и CMS, но работает совершенно иначе.

хоть он тоже Generational GC, у него нет разделения памяти для поколений. вместо этого каждое поколение - набор областей, что позволяет гибко менять размер поколений.

но добавляются еще два типа поколений:

- Humongous (объекты >50% кучи)
- Available (неиспользуемое пространство)

куча разбивается на набор областей одинакового размера и они сканируются в несколько потоков. каждая область может динамически становиться как старой, так и молодой.

после marking’а G1 знает, в каких областях больше всего мусора. если хочется меньше stop-the-world, то выбираются только несколько областей с мусором, если нет, то G1 проходится по большинству областей.

**Алгоритм:**

- Young Generation: Copying
	- Копирует живые объекты между регионами Young Generation

- Old Generation: Concurrent Mark-Sweep + Copying
	- Делит heap на регионы (1–32 МБ)
	- Выполняет конкурентную маркировку для определения живых объектов.
	- Очищает регионы с наибольшим количеством мусора (Garbage-First)
	- Перемещает живые объекты из "грязных" регионов в новые (копирование).

**Особенности:** 
- Предсказуемые паузы через -XX:MaxGCPauseMillis.
- Компактизация выполняется постепенно, минимизируя фрагментацию.

**Когда использовать?**:
- Серверные приложения с кучей >4 ГБ
- Баланс задержек и пропускной способности

## Epsilon GC _(experimental)_

часть JDK 11. У Epsilon нет механизма восстановления памяти, и как только куча будет забита, JVM тупо завершит работу :)

## Shenandoah GC _(experimental)_

часть JDK 15

большая часть цикла сборки мусора выполняется одновременно с потоками приложений. G1 может очищать области кучи только когда выполняется stop-the-world, а Shenandoah делает это одновременно с выполнением приложения.

Ну и очев из-за этого процессору может быть очень больно
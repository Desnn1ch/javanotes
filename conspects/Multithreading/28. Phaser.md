Вернемся к примеру из `CyclicBarrier`, но теперь представим, что у каждого потока в разных фазах разное количество задач:
![[Screenshot 2025-08-28 at 16.30.28.png]]

В случае с `CyclicBarrier` очевидно, что мы не дойдем до конца, потому что на второй фазе `CyclicBarrier` встанет с счетчиком = 1, и верхние 2 потока так и не смогут дойти до конца.

На этот случай к нам приходит `Phaser`:
![[Screenshot 2025-08-28 at 16.34.41.png]]

_Note:_ `arriveAndDeregister` не блокирует поток, то есть мы как бы отпускаем поток из `Phaser`-а и он дальше может идти и заниматься своими делами.

Очев, что когда кол-во зарегестрированных потоков и потоков, которых необходимо дождаться для перехода к некст фазе = 0, `Phaser`  становится терминированным, то есть заканчивает свою работу вобщем. 

В `Phaser`-е есть такой метод, как `onAdvance(int phase, int parties)`. Он вызывается каждый раз, при переходе на новую фазу. Его также можно переопределить, например всегда возвращать `false`. Тогда наш фазер никогда на перейдет в состояние `Терминирован`.
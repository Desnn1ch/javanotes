Для потокобезпасной работы мы раньше делали вот так:
![[Screenshot 2025-08-27 at 17.39.22.png]]

Ну очевидно у этого решения есть проблемка, а именно, часть кода внутри метода или вообще весь метод могут выполняться только 1 потоком, все остальные потоки в этот момент `BLOCKED`. 
![[Screenshot 2025-08-27 at 17.40.06.png]]В общем и целом блокировки являются тяжеловесным процессом и могут приводить к проблемам с производительностью. К счастью, у нас есть решение этих проблем - `CAS`

`CAS` - позволяет обеспечить потокобезопасность без блокировок. Является атомарной. Является эффективной альтернативой локам.

_Note:_ алгоритм называются неблокирующим, если сбой или приостановка одного потока не вызывает сбой или приостановку другого потока

Операция `CAS` имеет 3 операнда:
- Ячейка памяти `CELL` на которой выполняются все операции
- Ожидаемое старое значение этой ячейки `EXPECTED`
- Новое значение этой ячейки `NEW`
![[Screenshot 2025-08-27 at 17.49.21.png]]

Если старое значение не равно ожидаемому, возвращаем `false`, что означает, что другой поток уже успел изменить значение в нашей ячейке памяти. Исходя из данного метода вызывающая сторона может принять решение - принять дальнейшие попытки изменения или нет. 

_Note:_ в Java методы CAS являются нативными и выполняются атомарно

Пример, как это будет выполняться:
![[Screenshot 2025-08-27 at 17.54.56.png]]

### Преимущества `CAS` (Compare-And-Swap)

1. **Низкозатратность**
    - В отличие от блокировок (`synchronized`, `ReentrantLock`), CAS не заставляет поток входить в ядро ОС, ставить мьютекс и ждать.
    - Это всего одна атомарная машинная инструкция на уровне процессора → очень быстро.
    
2. **Неблокирующий подход**
    - Потоки не блокируются. Если CAS не удался (значение изменилось), поток просто повторяет операцию.
    - Нет риска классического _deadlock_ (взаимной блокировки потоков).
    
3. **Оптимистичный подход**
    - CAS исходит из предположения: "скорее всего, никто не изменит значение одновременно со мной".
    - Проверка делается только в момент обновления: если значение совпало → обновляем, иначе пробуем снова.
    - Это эффективно при высокой конкуренции, так как большинство операций проходят без конфликтов.

### Недостатки `CAS`

1. **Голодание (starvation)**
    - Если много потоков конкурируют за одно и то же значение, один "несчастный" поток может бесконечно проигрывать гонку и никогда не завершить операцию.
    - То есть формально блокировки нет, но на практике поток "голодает".
    
2. **ABA-проблема**
    - Ситуация: поток ожидает, что значение = `A`.
    - Пока он думает, другое ядро изменило `A → B → A`.
    - CAS сравнивает: было `A`, сейчас тоже `A` → думает, что ничего не изменилось, и успешно обновляет.
    - Но на самом деле значение _изменялось_, и это может привести к логическим ошибкам.

Для решения ABA применяют **метки версий** или **AtomicStampedReference** в Java, где вместе со значением хранится счётчик изменений.
наконец-то я дошел до этого ебаного слова ради которого я все это делал :)

Представим, что у нас есть код, который выполняется несколькими потоками, но зачем-то мы захотели, чтобы этот код выполнялся максимум двумя потоками, и в то же время не ограничивать выполнение кода только одним потоком.
![[Screenshot 2025-08-27 at 21.22.26.png]]

И нам поможет конечно же семафор. Вот так вот он создается:
```java
private final Semaphore semaphore = new Semaphore(2);

public void doWork() throws InterruptedException {
	this.semaphore.acquire();
	try {
		// code
	} finally {
		this.semaphore.release();
	}
}
```
`acquire()` говорит типа я взял у вас одно разрешение, осталось 1. Если же осталось 0 разрешений, тогда текущий поток блокируется в точке вызова `acquire()`, пока какой-то поток не вернет (`release()`) ранее захваченное им разрешение

Есть еще вот такие методы:

1. **`acquire(int permits)`**
    - Запрашивает указанное количество разрешений (`permits`).
    - Если доступных разрешений меньше → поток блокируется, пока они не освободятся.
    - Аналог `acquire()` для одного разрешения, но можно сразу несколько.

2. **`release(int permits)`**
    - Освобождает указанное количество разрешений (это ваще угар потому что если у нас было изначально 2 разрешения передано в конструктор семаформа - то с помощью этого метода можно нахуярить их еще больше прям в коде, типа было 2, стало 3, потом 10 и тд).
    - Счётчик увеличивается, и другие ожидающие потоки могут продолжить.

3. **`acquireUninterruptibly()`**
    - То же самое, что `acquire()`, но **невозможно прервать** с помощью `Thread.interrupt()`.
    - Поток будет ждать разрешение, даже если его прервали.

4. **`tryAcquire()`**
    - Пытается получить разрешение **немедленно**, без ожидания.
    - Возвращает `true`, если получилось, или `false`, если разрешений нет.
    - Есть перегрузка с таймаутом: `tryAcquire(long timeout, TimeUnit unit)`.

5. **`availablePermits()`**
    - Возвращает текущее количество свободных разрешений.
    - Удобно, чтобы узнать “загруженность”.

6. **`new Semaphore(int permits, boolean fair)`**
    - Конструктор.
    - `permits` — сколько разрешений доступно одновременно.
    - `fair` — режим справедливости:
        - `false` (по умолчанию) → кто быстрее запросил, тот и занял (может быть starvation).
        - `true` → очередность потоков (FIFO).

### Го напишем свой пул объектов по аналогии с конекшн пулом

Если коротко, суть в том, что создавать `Connection` для взаимодействия между кодом и базой - сильно дорогостоящая операция. Чтобы оптимизировать все это дело, можно создать заранее пул конекшнов и взаимодействовать с ними таким образом, чтобы как только какая-то часть кода позаимодействовала с конекшном, она сразу отдала его обратно на пользование другому участку кода, а не тупо удалила.

Короче вобщем переиспользование и безотходное производство :)
![[Screenshot 2025-08-27 at 21.50.17.png]]

Вот такая у нас будет архитектура:
![[Screenshot 2025-08-27 at 21.53.36.png]]
`PoolObject<T>` - это просто обертка над нашим типа конекшном. В нем есть поле `boolean issued` - которое значит что конекшн был выдан/не выдан. Кол-во разрешений семафора = кол-во `PoolObject`-ов

Вот такая будет арх у `acquire()`:
![[Screenshot 2025-08-27 at 22.31.37.png]]
Стоит обратить внимание на то, что пул должен браться очев потокобезопасной, иначе вот:
![[Screenshot 2025-08-27 at 22.33.10.png]]

Также интересно что если этот метод сделать целиком `synchronized` - то мы получим Deadlock, потому что может возникнуть ситуация, когда 
- один поток пытается взять соединение, полностью забирает монитор `AbstractPool-а
- но в пуле свободных соединений нет, и он блокается из-за семафора
- другой поток пытается релизнуть разрешение семафора, но не может потому что монитор объекта спиздил предидущий поток, и этот поток также блочится
![[Screenshot 2025-08-27 at 22.38.41.png]]

Вот что мы имеем, `AbstractPool`:
```java
package org.gerasic;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.concurrent.Semaphore;  
import java.util.function.Supplier;  
  
import static java.util.stream.IntStream.range;  
  
public abstract class AbstractPool<T> {  
    private final List<PoolObject<T>> poolObjects;  
    private final Semaphore semaphore;  
  
    public AbstractPool(final Supplier<T> objectSupplier, final int size) {  
        this.poolObjects = createPoolObjects(objectSupplier, size);  
        this.semaphore = new Semaphore(size);  
    }  
    
    public final T acquire() {  
        semaphore.acquireUninterruptibly();  
        return acquireObject();  
    }  
    
    public final void release(final T object) {  
        if (releaseObject(object)) {  
            semaphore.release();  
        }    
	}  
	
    private synchronized boolean releaseObject(final T object) {  
        return poolObjects.stream()  
                .filter(PoolObject::isIssued)  
                .filter(poolObject -> 
		                Objects.equals(poolObject.getObject(), 
		                object))  
                .findFirst()  
                .map(this::cleanPoolObject)  
                .isPresent();  
    }  
    
    private static <T> List<PoolObject<T>> createPoolObjects(
		    final Supplier<T> objectSupplier, 
		    final int size) {  
		    
        return range(0, size)  
                .mapToObj(i -> objectSupplier.get())  
                .map(object -> new PoolObject<>(object, false))  
                .toList();  
    }  
    
    private synchronized T acquireObject() {  
        return this.poolObjects.stream()  
                .filter(poolObject -> !poolObject.isIssued())  
                .findFirst()  
                .map(AbstractPool::markAsIssued)  
                .map(PoolObject::getObject)  
                .orElseThrow(IllegalStateException::new);  
    }  
    
    private static <T> PoolObject<T> markAsIssued(final PoolObject<T> poolObject) {  
        poolObject.setIssued(true);  
        return poolObject;  
    }  
    
    private PoolObject<T> cleanPoolObject(final PoolObject<T> poolObject) {  
        poolObject.setIssued(false);  
        cleanObject(poolObject.getObject());  
        return poolObject;  
    }  
    
    protected abstract void cleanObject(final T object);  
	  
	  
	  
    private static final class PoolObject<T> {  
        private final T object;  
        private boolean issued;  
  
        public PoolObject(final T object, final boolean issued) {  
            this.object = object;  
            this.issued = issued;  
        }  
        public T getObject() {  
            return this.object;  
        }  
        public boolean isIssued() {  
            return this.issued;  
        }  
        public void setIssued(final boolean issued) {  
            this.issued = issued;  
        }    
	}
}
```

Теперь сделаем из нашего пула объектов `ConnectionPool`:
![[Screenshot 2025-08-27 at 23.51.30.png]]

`Connection`:
```java
package org.gerasic;  
  
import static java.util.Objects.hash;  
  
public final class Connection {  
    private final long id;  
    private boolean autoCommit;  
  
    public Connection(final long id, final boolean autoCommit) {  
        this.id = id;  
        this.autoCommit = autoCommit;  
    }  
    public long getId() {  
        return this.id;  
    }  
    public void setAutoCommit(final boolean autoCommit) {  
        this.autoCommit = autoCommit;  
    }  
    public boolean isAutoCommit() {  
        return this.autoCommit;  
    }  
    @Override  
    public boolean equals(final Object otherObject) {  
        if (this == otherObject) {  
            return true;  
        }  
        if (otherObject == null) {  
            return false;  
        }  
        if (this.getClass() != otherObject.getClass()) {  
            return false;  
        }  
        final Connection other = (Connection) otherObject;  
        return this.id == other.id && this.autoCommit == other.autoCommit;  
    }  
    @Override  
    public int hashCode() {  
        return hash(this.id, this.autoCommit);  
    }  
    @Override  
    public String toString() {  
        return this.getClass().getName() +  
                "[id=" + this.id + ", autoCommit=" + this.autoCommit + "]";  
    }
}
```

`ConnectionPool`:
```java
package org.gerasic;  
  
import java.util.function.Supplier;  
  
public class ConnectionPool extends AbstractPool<Connection> { 
 
    public ConnectionPool(int size) {  
        super(new ConnectionSupplier(), size);  
    }  
    
    private static final class ConnectionSupplier 
	    implements Supplier<Connection> {  
	    
        private long mextConnectionId;  
  
        @Override  
        public Connection get() {  
            return new Connection(this.mextConnectionId++, true);  
        }   
	}  
	 
    @Override  
    protected void cleanObject(Connection connection) {  
        connection.setAutoCommit(true);  
    }
}
```

Теперь для теста нашего кода сделаем вот такую таску:
![[Screenshot 2025-08-28 at 00.03.53.png]]

`AbstractPoolTask`:
```java
package org.gerasic;  
  
import static java.lang.System.out;  
  
public abstract class AbstractPoolTask<T> implements Runnable {  
  
    private final AbstractPool<T> pool;  
  
    public AbstractPoolTask(final AbstractPool<T> pool) {  
        this.pool = pool;  
    }  
    
    @Override  
    public final void run() {  
        final T object = this.pool.acquire();  
        try {  
            out.printf("%s was acquired%n", object);  
            this.handle(object);  
        } finally {  
            out.printf("%s is being released%n", object);  
            this.pool.release(object);  
        }    
	}  
    protected abstract void handle(final T object);  
}
```

`ConnectionPoolTask`:
```java
package org.gerasic;  
  
import static java.lang.Thread.currentThread;  
import static java.util.concurrent.TimeUnit.SECONDS;  
  
public final class ConnectionPoolTask extends AbstractPoolTask<Connection> {  
  
    public ConnectionPoolTask(final AbstractPool<Connection> pool) {  
        super(pool);  
    }  
    
    @Override  
    protected void handle(final Connection connection) {  
        try {  
            connection.setAutoCommit(false);  
            SECONDS.sleep(3);  
        } catch (final InterruptedException interruptedException) {  
            currentThread().interrupt();  
        }    
	}
}
```

`ThreadUtil` для всякого разного:
```java
package org.gerasic;  
  
import static java.util.Arrays.stream;  
import static java.util.stream.IntStream.range;  
  
public final class ThreadUtil {  
  
    public static Thread[] createThreads(
		    final Runnable task, 
		    final int amountOfThreads) { 
		     
        return range(0, amountOfThreads)  
                .mapToObj(i -> new Thread(task))  
                .toArray(Thread[]::new);  
    }  
    
    public static void startThreads(final Thread[] threads) {  
        stream(threads).forEach(Thread::start);  
    }  
    
    private ThreadUtil() {  
        throw new UnsupportedOperationException();  
    }
}
```

Заветный `main`:
```java
package org.gerasic;  
  
public class Main {  
    public static void main(final String... args) {  
        final int poolSize = 3;  
        final ConnectionPool pool = new ConnectionPool(poolSize);  
  
        final ConnectionPoolTask poolTask = new ConnectionPoolTask(pool);  
        final int threadCount = 15;  
        final Thread[] threads = ThreadUtil.createThreads(
		        poolTask, 
		        threadCount);
		  
        ThreadUtil.startThreads(threads);  
    }
}
```

Вывод:
```java
org.gerasic.Connection[id=0, autoCommit=true] was acquired
org.gerasic.Connection[id=1, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=false] is being released
org.gerasic.Connection[id=1, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=true] was acquired
org.gerasic.Connection[id=1, autoCommit=true] was acquired
org.gerasic.Connection[id=1, autoCommit=false] is being released
org.gerasic.Connection[id=2, autoCommit=false] is being released
org.gerasic.Connection[id=1, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=true] was acquired
org.gerasic.Connection[id=0, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=false] is being released
org.gerasic.Connection[id=1, autoCommit=false] is being released
org.gerasic.Connection[id=2, autoCommit=true] was acquired
org.gerasic.Connection[id=1, autoCommit=true] was acquired
org.gerasic.Connection[id=0, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=false] is being released
org.gerasic.Connection[id=2, autoCommit=true] was acquired
org.gerasic.Connection[id=1, autoCommit=false] is being released
org.gerasic.Connection[id=1, autoCommit=true] was acquired
org.gerasic.Connection[id=0, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=true] was acquired
org.gerasic.Connection[id=2, autoCommit=false] is being released
org.gerasic.Connection[id=1, autoCommit=false] is being released
org.gerasic.Connection[id=0, autoCommit=false] is being released

BUILD SUCCESSFUL in 18s
```

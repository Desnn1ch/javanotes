Разберем работу брокера сообщений. 

`MessageModel`:
```java
package by.zuevlad.messagetransport.model;
import java.util.Objects;

public final class Message {
    private final String data;

    public Message(final String data) {
        this.data = data;
    }

    public String getData() {
        return this.data;
    }

    @Override
    public boolean equals(final Object otherObject) {
        if (this == otherObject) return true;
        if (otherObject == null || getClass() != otherObject.getClass()) return false; 

        final Message other = (Message) otherObject;       
        return Objects.equals(this.data, other.data);       
    }

    @Override
    public int hashCode() {
        return Objects.hash(data);                          
    }

    @Override
    public String toString() {
        return this.getclass().getName() + "[data = " + this.data + "]";
    }
}
```

`MessageBroker`:
```java
import java.util.ArrayDeque;
import java.util.Queue;

public final class MessageBroker {
    private final Queue<Message> messagesToBeConsumed;
    private final int maxStoredMessages;

    public MessageBroker(final int maxStoredMessages) {
        this.messagesToBeConsumed = new ArrayDeque<>(maxStoredMessages);
        this.maxStoredMessages = maxStoredMessages;
    }

    public synchronized void produce(final Message message) throws InterruptedException {
	    this.messagesToBeConsumed.add(message);
    }

    public synchronized Message consume() throws InterruptedException {
	    return this.messagesToBeConsumed.poll();
    }
}
```

`MessageProducingTask`:
```java
public final class MessageProducingTask implements Runnable {
	private static final String MESSAGE_OF_MESSAGE_IS_PRODUCED = "Message '%s' is produced.\n";
	private final MessageBroker messageBroker;
	private final MessageFactory messageFactory;
	
	public MessageProducingTask(MessageBroker messageBroker) {
		this.messageBroker = messageBroker;
		this.messageFactory = new MessageFactory();
	}
	
	@Override
	public void run() {
	    try {
	        while (!currentThread().isInterrupted()) {
	            final Message producedMessage = this.messageFactory.create();
	            SECONDS.sleep(SECONDS_DURATION_TO_SLEEP_BEFORE_PRODUCING);
	            this.messageBroker.produce(producedMessage);
	            out.printf(MESSAGE_OF_MESSAGE_IS_PRODUCED, producedMessage);
	        }
	    } catch (final InterruptedException interruptedException) {
	        currentThread().interrupt();
	    }
	}
	
    private static final class MessageFactory {
        private static final int INITIAL_NEXT_MESSAGE_INDEX = 1;
        private static final String TEMPLATE_CREATED_MESSAGE_DATA = "Message#%d";

        private int nextMessageIndex;

        public MessageFactory() {
            this.nextMessageIndex = INITIAL_NEXT_MESSAGE_INDEX;
        }

        public Message create() {
            return new Message(format(TEMPLATE_CREATED_MESSAGE_DATA, this.nextMessageIndex++));
        }
    }
}
```

`MessageConsumingTask`:
```java
public final class MessageConsumingTask implements Runnable {
    private static final int SECONDS_DURATION_TO_SLEEP_BEFORE_CONSUMING = 1;
    private static final String TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED = "Message '%s' is consumed. \n";

    private final MessageBroker messageBroker;

    public MessageConsumingTask(final MessageBroker messageBroker) {
        this.messageBroker = messageBroker;
    }

    @Override
	public void run() {
	    try {
	        while (!currentThread().isInterrupted()) {
	            SECONDS.sleep(SECONDS_DURATION_TO_SLEEP_BEFORE_CONSUMING);
	            final Message consumedMessage = this.messageBroker.consume();
	            out.printf(TEMPLATE_MESSAGE_OF_MESSAGE_IS_CONSUMED, consumedMessage);
	        }
	    } catch (final InterruptedException interruptedException) {
	        currentThread().interrupt();
	    }
	}
}
```

`main`:
```java
import by.zuevlad.messagetransport.broker.MessageBroker;
import by.zuevlad.messagetransport.consumer.MessageConsumingTask;
import by.zuevlad.messagetransport.producer.MessageProducingTask;

public final class Runner {
    public static void main(final String... args) {
        final int brokerMaxStoredMessages = 5;
        final MessageBroker messageBroker = new MessageBroker(brokerMaxStoredMessages);

        final Thread producingThread = new Thread(new MessageProducingTask(messageBroker));
        final Thread consumingThread = new Thread(new MessageConsumingTask(messageBroker));

        producingThread.start();
        consumingThread.start();
    }
}
```

В данной реализации 2 проблемы: 

1. Если cunsumer будет быстрее потреблять сообщения, чем producer отправлять - consumer в большинстве случаев будет читать `null`, что не хорошо.
2. Если producer будет быстрее отправлять сообщения, чем consumer потреблять - очередь тупо заполнится до отказа

### Как порешать проблемы?

Давайте попробуем в методе `consume()` просто ждать пока очередь пустая:
```java
import java.util.ArrayDeque;
import java.util.Queue;

public final class MessageBroker {
    private final Queue<Message> messagesToBeConsumed;
    private final int maxStoredMessages;

    public MessageBroker(final int maxStoredMessages) {
        this.messagesToBeConsumed = new ArrayDeque<>(maxStoredMessages);
        this.maxStoredMessages = maxStoredMessages;
    }

    public synchronized void produce(final Message message) throws InterruptedException {
        while (messagesToBeConsumed.size() == maxStoredMessages) {
            wait();
        }
        messagesToBeConsumed.add(message);
        notifyAll();
    }

    public synchronized Message consume() throws InterruptedException {
        while (messagesToBeConsumed.isEmpty()) {

        }

        return messagesToBeConsumed.poll();
    }
}
```

И что же произойдет? А ничего. Мы в бесконечном лупе застрянем. Очевидно потому что консьюмер методом `synchronized` захватил монитор `MessageBroker`-a, и ждет сообщений от продьюсера, а продьюсер ждет пока консьюмер отдаст монитор `MessageBroker`-a. Это одна из разновидностей Deadlock-a. Уровень есть такой в гд, я его прошел кстати.
![[Screenshot 2025-08-25 at 17.38.35.png]]

### Блин че-то не получилось, что же делать? 

Вау, `wait()` и `notify()`
![[Screenshot 2025-08-25 at 17.43.46.png]]

- Вызывая метод `wait()` поток как бы говорит, тип мои полномочия на этом все, я жду, и отдает монитор
- И только после `notify()` потоку дают по голове, он оживляется и забирает монитор обратно

```java
import java.util.ArrayDeque;
import java.util.Queue;

public final class MessageBroker {
    private final Queue<Message> messagesToBeConsumed;
    private final int maxStoredMessages;

    public MessageBroker(final int maxStoredMessages) {
        this.messagesToBeConsumed = new ArrayDeque<>(maxStoredMessages);
        this.maxStoredMessages = maxStoredMessages;
    }

    public synchronized void produce(final Message message) {
        try {
            while (messagesToBeConsumed.size() == maxStoredMessages) {
                wait();
            }
            messagesToBeConsumed.add(message);
            notify();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); 
        }
    }

    public synchronized Message consume() {
        try {
            while (messagesToBeConsumed.isEmpty()) {
                wait();
            }
            Message msg = messagesToBeConsumed.poll();
            notify();
            return msg;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); 
            throw new RuntimeException(e);
        }
    }
}
```

_Note:_ методы `wait()` и `notify()` могут вызываться только внутри `synchronized`-методов или `synchronized`-блоков

_Note:_ 
- `notify()` пробуждает **один** поток, который находится в состоянии `WAITING` на том же мониторе (вызвал `wait()`), **но** не освобождает монитор немедленно.
    
- Поток, который вызвал `notify()`, **продолжает выполнять код внутри того же `synchronized` блока** и держит монитор до выхода из него.
    
- Пробуждённый поток не побежит сразу: он переходит из `WAITING` в состояние ожидания монитора и сможет продолжить только **после** того, как монитор будет освобождён (когда уведомивший поток выйдет из `synchronized`). При возврате из `wait()` он уже будет владеть монитором.

### А го усложним задачу? Мы же ебанутые

Крч мне впадлу это сюда конспектить, все лежит в MyProjects/Java/Multithreading/Broker, там я сделал (переписал) вот такую штуку![[Screenshot 2025-08-25 at 20.38.52.png]]
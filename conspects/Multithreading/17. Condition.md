### `Lock::Condition`

Допустим нам нужно реализовать коллекцию `BoundedBuffer`:
- Коллекция ограничена кол-вом элементов, которое мы задали при инициализации.
- Коллекция должна быть потокобезопасной
- Если какой-то поток пытается достать элемент из нашего буффера, и там элемента нет - поток должен подождать, пока туда положат элемент
- Если буффер заполнен и какой-то поток пытается положить туда элемент - он должен опять таки подождать, пока буффер освободится
- LIFO

Вот как она будет выглядеть:
`BoundedBuffer`
```java
package org.gerasic.boundedbuffer;  
  
import java.util.Objects;  
import java.util.concurrent.locks.Condition;  
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
import java.util.stream.Collectors;  
import java.util.stream.Stream;  
  
import static java.lang.System.out;  
  
public final class BoundedBuffer<T> {  
    private final T[] elements;  
    private final Lock lock;  
    private final Condition condition;  
    private int size;  
  
    @SuppressWarnings("unchecked")  
    public BoundedBuffer(final int capacity) {  
        this.elements = (T[]) new Object[capacity];  
        this.lock = new ReentrantLock();  
        this.condition = lock.newCondition();  
    }  
    
    public boolean isFull() {  
        lock.lock();  
        try {  
            return this.size == this.elements.length;  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public boolean isEmpty() {  
        this.lock.lock();  
        try {  
            return this.size == 0;  
        } finally {  
            this.lock.unlock();  
        }    
	}  
	
    public void put(final T element) {  
        lock.lock();  
        try {  
            while (isFull()) {  
                condition.await();  
            } 
                       
            this.elements[this.size] = element;  
            this.size++;  
            out.printf(
		            "%s was put in buffer. Result buffer: %s%n", 
		            element, 
		            this); 
            this.condition.signalAll();  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public T take() {  
        lock.lock();  
        try {  
            while (this.isEmpty()) {  
                condition.await();  
            }            
            final T result = this.elements[this.size - 1];  
            this.elements[this.size - 1] = null;  
            this.size--;  
            out.printf(
				        "%s was taken from buffer. Result buffer: %s%n", 
				        result, 
				        this);  
            this.condition.signalAll();  
            return result;  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    @Override  
    public String toString() {  
        lock.lock();  
        try {  
            return "{" +  
                    Stream.of(this.elements)  
                            .limit(this.size)  
                            .map(Objects::toString)  
                            .collect(Collectors.joining(", ")) +  
                    "}";  
        } finally {  
            lock.unlock();  
        }    
	}
}
```

_Note:_ `Thread::wait` и `Thread::notify` нельзя использовать вне метода `synchronized`. Здесь есть полные клоны этих методов:

- `wait()` - `Condition::await`
- `notify()` - `Condition::signal`
- `notifyAll()` - `Condition::signalAll`

### Преимущество использования интерфейса `Condition`

#### Можно иметь столько `Condition` , сколько захочется

Представим теперь что у нашего `BoundedBuffer` есть 5 продьюссеров и 5 консьюмеров.
По старым примерам мы будем будить всех методом `signalAll`, что вобщем-то не слишком оптимально, потому что разбудить нам в случае, когда буффер заполнен, нужно именно консьюмеров, и аналогично наоборот

![[Screenshot 2025-08-26 at 20.10.35.png]]

Как раз засчет двух кондишнов мы можем добиться такого поведения (изменены только методы put и take):
```java
package org.gerasic.boundedbuffer;  
  
import java.util.Objects;  
import java.util.concurrent.locks.Condition;  
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
import java.util.stream.Collectors;  
import java.util.stream.Stream;  
  
import static java.lang.System.out;  
  
public final class BoundedBuffer<T> {  
    private final T[] elements;  
    private final Lock lock;  
    private final Condition notFull;  
    private final Condition notEmpty;  
    private int size;  
  
    @SuppressWarnings("unchecked")  
    public BoundedBuffer(final int capacity) {  
        this.elements = (T[]) new Object[capacity];  
        this.lock = new ReentrantLock();  
        this.notFull = lock.newCondition();  
        this.notEmpty = lock.newCondition();  
    }  
    
    public boolean isFull() {  
        lock.lock();  
        try {  
            return this.size == this.elements.length;  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public boolean isEmpty() {  
        this.lock.lock();  
        try {  
            return this.size == 0;  
        } finally {  
            this.lock.unlock();  
        }    
	}  
	
    public void put(final T element) {  
        lock.lock();  
        try {  
            while (isFull()) {  
                notFull.await();  
            }            this.elements[this.size] = element;  
            this.size++;  
            out.printf(
		            "%s was put in buffer. Result buffer: %s%n", 
		            element, 
		            this);  
            this.notEmpty.signal();  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public T take() {  
        lock.lock();  
        try {  
            while (this.isEmpty()) {  
                notEmpty.await();  
            }            final T result = this.elements[this.size - 1];  
            this.elements[this.size - 1] = null;  
            this.size--;  
            out.printf(
		            "%s was taken from buffer. Result buffer: %s%n", 
		            result, 
		            this);  
            this.notFull.signal();  
            return result;  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    @Override  
    public String toString() {  
        lock.lock();  
        try {  
            return "{" +  
                    Stream.of(this.elements)  
                            .limit(this.size)  
                            .map(Objects::toString)  
                            .collect(Collectors.joining(", ")) +  
                    "}";  
        } finally {  
            lock.unlock();  
        }    
	}
}
```

### `Condition::awaitUninterruptibly`

Просто `await` который не кидает `InterruptedException` и никак не реагирует на прерывания. Если текущий поток был прерван - то он все равно будет ждать `signal` или `signalAll`. После выхода из `awaitUninterruptibly()` поток **снова будет в состоянии "interrupted"** (флаг прерывания выставлен в `true`).

Есть еще вот такие методы:

`long awaitNanos(long nanosTimeout) throws InterruptedException;`
`boolean await(long time, TimeUnit unit) throws InterruptedException:`

они итак очев поэтому я не буду их расписывать :)

_Note:_ экземпляры `Condition` наследуют от `Lock`-a fairness



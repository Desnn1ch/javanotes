Представим что у нас есть 2 потока: консьюмер и продьюсер. Мы захотели сделать так, чтобы у каждого из потоков была своя очередь. Продьюсер будет отдавать свою очередь консьюмеру, только когда заполнит ее, и взамен забирать пустую очередь. И так до упора![[Screenshot 2025-08-28 at 15.58.22.png]]

Сделать это можно с помощью `Exchanger`-a:
![[Screenshot 2025-08-28 at 15.59.49.png]]

`Exchanger` - параметризированный класс, и параметр этого класса - это то, чем будут обмениваться потоки.

Пример:
```java
import java.util.concurrent.Exchanger;

public class ExchangerExample {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();

        Thread producer = new Thread(() -> {
            try {
                String data = "Message from Producer";
                System.out.println("Producer готовится отдать: " + data);
                String response = exchanger.exchange(data);
                System.out.println("Producer получил: " + response);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                String data = "Message from Consumer";
                System.out.println("Consumer готовится отдать: " + data);
                String response = exchanger.exchange(data);
                System.out.println("Consumer получил: " + response);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();
    }
}
```

Вывод:
```java
Producer готовится отдать: Message from Producer
Consumer готовится отдать: Message from Consumer
Producer получил: Message from Consumer
Consumer получил: Message from Producer
```

### Важные моменты про `Exchanger`

1. **Работает только попарно**
    - В один момент в обмене участвуют ровно **два потока**.
    - Если поток вызвал `exchange()` и второго нет → он будет ждать.
    
2. **Очередь "ожидания"**
    - Если несколько потоков вызвали `exchange()`, они будут **попарно спариваться** в порядке прихода.
    - Третий поток не "встанет в очередь" к первым двум, а будет ждать, пока освободится "партнёр".
    
3. **Блокировка и таймауты**
    - По умолчанию `exchange()` блокируется бесконечно.
    - Можно задать таймаут:
        `exchanger.exchange(data, 2, TimeUnit.SECONDS);`
        Если второй поток не придёт вовремя → выбросится `TimeoutException`.
    
4. **Работа с `null`**
    - `Exchanger` нормально работает с `null`: можно передавать `null` как объект.
    
5. **Потокобезопасность**
    - `Exchanger` реализован так, чтобы одновременно работали много пар потоков.
    - У каждой пары — свой "слот".
    
6. **Можно использовать как барьер**
    - Если два потока должны встретиться в одной точке кода и синхронизироваться, они могут вызвать `exchange(null)` — просто чтобы "подождать друг друга".
    
7. **Производительность**
    - `Exchanger` быстрее и легче, чем `BlockingQueue`, если нужно только **один-к-один обмен**.
    - Но если тебе надо взаимодействие "один ко многим" или "многие ко многим" → лучше использовать `BlockingQueue`.
    
8. **Случайное применение**
    - Можно использовать для реализации двунаправленного pipeline:  
        один поток генерирует данные → другой обрабатывает и возвращает результат обратно через `Exchanger`.

### Когда НЕ стоит использовать

- Если у тебя больше двух потоков, которые должны обмениваться общими данными.
- Если производитель и потребитель не синхронны (один работает быстрее другого) → тогда `BlockingQueue`будет лучше, потому что `Exchanger` всегда **требует партнёра прямо сейчас**.
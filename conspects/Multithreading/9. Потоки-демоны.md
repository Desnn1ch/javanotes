Потоки-демоны - это потоки, которые выполняют работу в фоновом режиме, но не является ее отъемлемой частью. Таким образом, когда все потоки-не демоны заканчивают свою работу - программа завершается, даже если потоки-демоны еще выполняются.

В классических потоках например если поток main закончил свою работу, но породил еще потоков-не демонов - тогда программа не завершится, пока все потоки не закончат свою работу.

main-поток не является демонов очев, проверить можно вот таким образом:
```java
import static java.lang.System.out;
import static java.lang.Thread.currentThread;

public final class Runner {
    public static void main(final String... args) {
        out.println(currentThread().isDaemon());
    }
}
```

Сделать поток демоном можно методом `Thread::setDaemon`

Домничество наследуется также как и приоритеты: если поток-демон создает новый поток - новый поток также будет демоном

```java
import static java.lang.System.out;
import static java.lang.String.format;
import static java.lang.Thread.currentThread;

public final class Runner {
    private static final String MESSAGE_TEMPLATE_THREAD_NAME_AND_DAEMON_STATUS = "%s : %b%n";

    public static void main(final String... args) throws InterruptedException {
        final Thread firstDaemonThread = new Thread(() -> {
            final Thread secondDaemonThread = new Thread(() ->
                printThreadNameAndDaemonStatus(currentThread())
            );

            secondDaemonThread.start();
            try {
                secondDaemonThread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            printThreadNameAndDaemonStatus(currentThread());
        });

        firstDaemonThread.setDaemon(true);
        firstDaemonThread.start();

        firstDaemonThread.join();
    }

    private static void printThreadNameAndDaemonStatus(final Thread thread) {
        out.printf(MESSAGE_TEMPLATE_THREAD_NAME_AND_DAEMON_STATUS,
                thread.getName(), thread.isDaemon());
    }
}
```
Вывод:
```java
Thread-0 : true
Thread-1 : true
```

Если вызвать `Thread::setDaemon` после ``Thread::start`` то в потоке, который пытался установить другого в демона вылетит исключение `IllegalThreadStateException`

Потоки-демоны не должны обращаться к файлам или БД, поскольку они могут быть прерваны в любой момент, и даже блок `finally` тут не поможет, пример:
```java
import static java.lang.System.out;
import static java.lang.Thread.currentThread;
import static java.util.concurrent.TimeUnit.SECONDS;

public final class Runner {
    public static void main(final String... args) throws InterruptedException {
        Thread worker = new Thread(new Task(), "worker-thread");
        worker.setDaemon(true);
        worker.start();
        
        TimeUnit.SECONDS.sleep(1);
    }

    private static final class Task implements Runnable {
        private static final String MESSAGE_START_WORKING = "I am working";
        private static final String MESSAGE_END_WORKING = "I am finished";
        private static final int WORKING_DURATION_IN_SECONDS = 5;

        @Override
        public void run() {
            try {
                out.println(MESSAGE_START_WORKING);
                SECONDS.sleep(WORKING_DURATION_IN_SECONDS);
            } catch (final InterruptedException interruptedException) {
                currentThread().interrupt();
            } finally {
                out.println(MESSAGE_END_WORKING);
            }
        }
    }
}
```
Вывод:
```java
I am working 
Process finished with exit code 0
```
То есть блок `finally` не отработал тк демон-поток автоскипнулся
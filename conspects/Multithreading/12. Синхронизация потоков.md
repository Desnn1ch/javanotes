Просто очев слайдик, говорящий о том, что данные HEAP могут быть повреждены разными потоками :)
![[Screenshot 2025-08-25 at 00.31.17.png]]

## Пример состояния гонок, атомарные операции

```java
import static java.lang.System.out;
import static java.util.stream.IntStream.range;

public final class Runner {
    private static int counter = 0;

    private static final int INCREMENT_AMOUNT_FIRST_THREAD = 500;
    private static final int INCREMENT_AMOUNT_SECOND_THREAD = 600;

    public static void main(final String... args) throws InterruptedException {
        final Thread firstThread  =
                createIncrementingCounterThread(INCREMENT_AMOUNT_FIRST_THREAD);
        final Thread secondThread =
                createIncrementingCounterThread(INCREMENT_AMOUNT_SECOND_THREAD);

        firstThread.start();
        secondThread.start();

        firstThread.join();
        secondThread.join();

        out.printf(counter);
    }

    private static Thread createIncrementingCounterThread(final int incrementAmount) {
        return new Thread(() -> range(0, incrementAmount).forEach(i -> counter++));
    }
}
```
Вывод: на фулл рандом там вывод, инкременты где-то теряются 
```
1093
Process finished with exit code 0
```

#### Почему? чзх

Планировщик потоков не может прервать выполнение атомарной операции. Очев.

`counter++` **не атомарная** операция. Под капотом это три шага:
1. прочитать `counter` из памяти/кеша
2. прибавить 1
3. записать обратно

Два потока могут сделать шаги (1) и (2) почти одновременно, и один из результатов перезатрёт другой — получаем «потерянные инкременты». `join()` лишь ждёт завершения, но **не делает операции потокобезопасными**. Ниже пикча наглядная![[Screenshot 2025-08-25 at 00.43.28.png]]![[Screenshot 2025-08-25 at 00.44.09.png]]

#### А как тогда понять что вообще является атомарной операцией, а что нет?

Замаппить в голове епта.

На уровне Java Memory Model атомарны (без доп. синхронизации):

1. **Чтение и запись** переменных следующих типов:
    - все примитивные, кроме `long` и `double` (то есть `boolean`, `byte`, `short`, `char`, `int`, `float`).
    - ссылки (например, `String s` или `Object o`).
    - `int x = 5;     // атомарная запись    int y = x;     // атомарное чтение`
    
2. **Чтение и запись `volatile` переменных**  
    Даже для `long` и `double` чтение/запись `volatile` гарантируется атомарной.
    
3. **Методы атомарных классов** из `java.util.concurrent.atomic`:
    - `AtomicInteger.incrementAndGet()`
    - `AtomicInteger.getAndIncrement()`
    - `AtomicReference.compareAndSet()`  
    - и все аналогичные (`AtomicLong`, `LongAdder`, `AtomicBoolean` и т.д.).

4. **Некоторые операции синхронизации**:
    - `synchronized` (взятие и освобождение монитора — атомарно).
    - `Lock.lock()/unlock()`.
    - `CountDownLatch.countDown()`.
    - `Semaphore.acquire()/release()`.

## Как решать проблему гонок? `Synchronized`

Вот такого поведения нам поможет добиться это волшебное слово:
![[Screenshot 2025-08-25 at 00.54.00.png]]

Выводим инкремент в отдельный метод и помечаем метод как `synchronized`:
```java
private static synchronized void incrementCounter() {
	counter++;
}
```

### И что же происходит под капотом, когда мы навешиваем на метод  `synchronized`?

#### Для начала нужно понять что такое монитор.    :)
![[Screenshot 2025-08-25 at 01.00.01.png]]

1. Когда какой-то поток пытается вызвать синхронизированный метод, он сначала проверяет был ли захвачен этот монитор каким-то другим потоком. О мониторе какого объекта сейчас неважно.

2. Если монитор спизжен - поток ждет пока другой поток закончит все свои дела с этим монитором (как и видно на схеме). Как раз именно в этот момент наш ожидающий поток находится в состоянии BLOCKED.

3. Когда монитор освобождается - поток конкурирует с другими потоками за этот монитор.

4. Короче монитор - это как самочка за которой хантятся самцы. Если самочка занята - самцы просто ждут пока самочка освободится :) Ебать я кринжовый хахахаха. Очевидно, что на одну самочку может быть только один самец. Но также самец обязан освободить самочку, когда закончит.

_Note:_ каждый объект в Java имеет только один монитор

_Note:_ если в рамках одного класса будет 2 synchronized-метода - тогда при вызове одного заблокируется и второй, потому что оба метода принадлежат одному классу, монитор которого уже занят.

#### Как нам в рамках одного класса не мешать 2-ум synchronized методам?

Ответом является `synchronized` в самом теле метода. Внутри тела `synchronized` можно указывать объект, по которому монитор будет забираться. 

Также таким образом можно синхронизировать не весь код метода, что очевидно хорошо, потому что чем меньше синхронизированного кода - тем меньше проеб по оптимизации. ![[Screenshot 2025-08-25 at 01.45.17.png]]

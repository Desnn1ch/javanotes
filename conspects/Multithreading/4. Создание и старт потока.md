Все программы, написанные на Java, запускаються в неявно созданном потоке main(). Вот таким образом можно узнать это:
![[Screenshot 2025-08-24 at 17.11.45.png]]

#### Есть 2 способа создания нового потока:

##### 1. С помощью override run()
![[Screenshot 2025-08-24 at 17.14.22.png]]Но лучше если мы класс нигде больше не используем - использовать анонимный класс: ![[Screenshot 2025-08-24 at 17.15.44.png]]

Мы вызываем метод start(), потому что если бы мы выбрали метод run() - тогда код из метода run() выполнился не в новом потоке, а в старом, то есть короче не создался бы поток новый

Пример компилируемого кода:
```java
import static java.lang.Thread.currentThread;

public final class Runner {
    public static void main(final String... args) {
        System.out.println(currentThread().getName());

        final Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println(currentThread().getName());
            }
        };

        thread.start();
    }
}
```
Вывод:
```java
main
Thread-0
```

##### 2. Можно написать реализацию функционального интерфейса Runnable и передать его в конструктор Thread:
```java
import static java.lang.System.out;
import static java.lang.Thread.currentThread;

public final class Runner {
    public static void main(final String... args) {
        final Runnable task = () -> out.println(currentThread().getName());
        final Thread thread = new Thread(task);

        thread.start();
    }
}
```
Вывод:
```java
Thread-0
```

Прикольная задачка для мозга. Сколько потоков создастся?
```java
import static java.lang.System.out;
import static java.lang.Thread.currentThread;
import static java.util.stream.IntStream.range;

public final class Runner {
    private static final int CREATED_THREADS_AMOUNT = 10;

    public static void main(final String... args) {
        final Runnable taskDisplayingThreadName =
                () -> out.println(currentThread().getName());

        final Runnable taskCreatingThreads = () ->
                range(0, CREATED_THREADS_AMOUNT)
                        .forEach(i -> startThread(taskDisplayingThreadName));

        startThread(taskCreatingThreads);
    }

    private static void startThread(final Runnable runnable) {
        final Thread thread = new Thread(runnable);
        thread.start();
    }
}
```
Ответ 11 (не считая main)
![[Pasted image 20250824173117.png]]

Второй способ создания потока более предпочтительный с точки зрения проектирования т.к. стоит отделять задачу от механизма ее выполнения. Если есть множество задач - то не эффективно под каждую задачу создавать отдельный поток, вместо этого лучше заранее подготовить пул потоков и отдавать в этот пул потоков таски
![[Screenshot 2025-08-24 at 23.08.47.png]]
### Планировщик потоков

Планировщик потоков - штука, которая решает какой поток будет выполняться ЦП-ом в данный квант времени

### Приоритеты потоков

- У потоков **есть приоритеты**. Если есть несколько потоков ожидающих запуска - планировщик запустит тот, что с большим приоритетом, это почему-то зависит от ОС. 

- Бывают ситуации, когда есть **несколько потоков с высоким приоритетом**, которые **не перестают быть активными**, и **есть потоки с низким приоритетом, которые ожидают запуска**, и при таком раскладе **менее приоритетные потоки могут вообще не выполниться**. Поэтому в подавляющем количестве случаев все **потоки должны выполняться с приоритетами по умолчанию**.

- Всего существует 10 приоритетов 1-10. По умолчанию поток равен 5. По умолчанию поток наследует приоритетность потока, который его создал.

Пример работы с приоритетами потоков:
```java
public final class Runner {
    private static final String MESSAGE_TEMPLATE_THREAD_NAME = "%s : %d%n";

    public static void main(final String... args) {
        currentThread().setPriority(MAX_PRIORITY);

        final Thread thread = new Thread(() -> 
            printNameAndPriority(currentThread())
        );

        thread.start();

        printNameAndPriority(currentThread());
    }

    private static void printNameAndPriority(final Thread thread) {
        out.printf(MESSAGE_TEMPLATE_THREAD_NAME, thread.getName(), thread.getPriority());
    }
}
```

### Почему приоритеты - это полная хуйня?

```java
import static java.lang.System.out;
import static java.lang.Thread.MAX_PRIORITY;

public final class Runner {
    private static final String MESSAGE_MAIN_THREAD_FINISHED = "Main thread is finished.";

    public static void main(final String... args) {
        final Thread thread = new Thread(new Task());
        thread.setPriority(MAX_PRIORITY);
        thread.start();

        out.println(MESSAGE_MAIN_THREAD_FINISHED);
    }

    private static final class Task implements Runnable {
        private static final int RANGE_MINIMAL_BORDER = 1;
        private static final int RANGE_MAXIMAL_BORDER = 100;

        @Override
        public void run() {
            for (int i = RANGE_MINIMAL_BORDER; i <= RANGE_MAXIMAL_BORDER; i++) {
                out.println(i);
            }
        }
    }
}
```

Вывод: 
```java
Main thread is finished.
1
2
...
100
```

Вобщем каждая ОС сама учитывает эти приоритеты. Неконсистентненько получается пон.
Допустим есть какой-то `counter`, который допустим 5 разных потоков пытаются прочитать методом `getValue()` с периодичность 0.005 с, вобщем мегабыстро. И допустим этот `counter` инкрементится раз в 5 секунд: 
![[Pasted image 20250826205356.png]]

И как мы помним в такой ситуации нужно сделать нечто подобное:
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public final class Counter {
    private final Lock lock = new ReentrantLock();
    private long value;

    public long getValue() {
        this.lock.lock();
        try {
            return this.value;
        } finally {
            this.lock.unlock();
        }
    }

    public void increment() {
        this.lock.lock();
        try {
            this.value++;
        } finally {
            this.lock.unlock();
        }
    }
}
```

И все будет работать, но у этого решения есть свои минусы. Например то, что пока элемент не инкрементится, нам и не нужно лочить монитор объекта, потому что очевидно `counter` не инкрементится, можно в несколько потоков спокойно доставать значение и не париться.
![[Screenshot 2025-08-26 at 20.57.14.png]]

Но в то же время, надо не забывать про то, что когда элемент инкрементится - все потоки читающие должны быть залочены. Такого поведения мы можем добиться с помощью `ReentrantReadWriteLock`:

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public final class Counter {
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock readLock = this.readWriteLock.readLock();
    private final Lock writeLock = this.readWriteLock.writeLock();
    private long value;

    public long getValue() {
        this.readLock.lock();
        try {
            return this.value;
        } finally {
            this.readLock.unlock();
        }
    }

    public void increment() {
        this.writeLock.lock();
        try {
            this.value++;
        } finally {
            this.writeLock.unlock();
        }
    }
}
```

НО: важно понимать, что вообще не факт, что `ReentrantReadWriteLock` ускорит программу. Там есть несколько аспектов, из-за которых поведение кажется вообще нелогичным. Например вот этот Counter с `ReadWrideLock` оказался медленнее на большом объеме данных. Поэтому важно тестить обе реализации.
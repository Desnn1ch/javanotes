Того же функционала что и с `synchronized` можно добиться с помощью `ReentrantLock`, но с `ReentrantLock` можно воспользоваться его доп. функциями.

Вот так выглядит определение `ReetnrantLock`-а 
![[Screenshot 2025-08-25 at 22.12.05.png]]
Создается экземпляр интерфейса `Lock` `ReentrantLock`, далее вызывает `lock.lock()` тем самым ставя блок для других потоков, далее выполняем какой-то потокобезопасный код и в блоке `finally` анлокаем все. Если в блоке `finally` не указать анлок, то пизда.

Также стоит обратить внимание на то, что `return` должен находится внутри блока `try`, чтобы данные не стали доступными слишком рано.

Напишем генератор четных чисел:
```java
import static java.lang.System.out;
import static java.util.stream.IntStream.range;

public final class Runner {
    public static void main(final String... args) {
        final EvenNumberGenerator evenNumberGenerator = new EvenNumberGenerator();

        final Runnable generatingTask = () ->
                range(0, 100).forEach(i -> out.println(evenNumberGenerator.generate()));

        final Thread firstThread = new Thread(generatingTask);
        firstThread.start();

        final Thread secondThread = new Thread(generatingTask);
        secondThread.start();

        final Thread thirdThread = new Thread(generatingTask);
        thirdThread.start();
    }

    private static final class EvenNumberGenerator {
        private int previousGenerated;

        public EvenNumberGenerator() {
            this.previousGenerated = -2;
        }

        public int generate() {
            return this.previousGenerated += 2;
        }
    }
}
```

Очевидно, что метод `generate()` не потокобезопасный, и его легко можно было бы изменить вот таким способом:
```java
public synchronized int generate() {
	return this.previousGenerated += 2;
}
```
И все бы сработало, но нас интересует `ReentrantLock`, для этого придется немного поменять класс `EvenNumberGenerator`:
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

private static final class EvenNumberGenerator {
    private final Lock lock;
    private int previousGenerated;

    public EvenNumberGenerator() {
        this.lock = new ReentrantLock();
        this.previousGenerated = -2;
    }

    public int generate() {
        this.lock.lock();
        try {
            return this.previousGenerated += 2;
        } finally {
            this.lock.unlock();
        }
    }
}
```

## Преимущества использования явных блокировок

Один из случае, когда нужно использовать явные блокировки, это когда в одном методе нужно поставить лок, во втором анлокнуть:
![[Screenshot 2025-08-25 at 22.26.52.png]]
`synchronized` здесь не поможет, потому что его возможности заканчиваются внутри одного блока

Пример:
```java
package org.gerasic;  
  
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
import java.util.function.IntConsumer;  
import java.util.stream.Stream;  
  
import static java.lang.System.out;  
import static java.lang.Thread.currentThread;  
import static java.util.stream.IntStream.range;  
  
public final class Main {  
    public static void main(final String... args) throws InterruptedException {  
        final Counter counter = new Counter();  
  
        final int incrementAmount = 10;  
        final Thread incrementingThread = new Thread(  
                createTaskDoingOperationOnCounter(
		                counter, 
		                i -> counter.increment(), 
		                incrementAmount),  
                "incrementer"  
        );  
  
        final int decrementAmount = 10;  
        final Thread decrementingThread = new Thread(  
                createTaskDoingOperationOnCounter(
		                counter, 
		                i -> counter.decrement(), 
		                decrementAmount),  
                "decrementer"  
        );  
  
        startThreads(incrementingThread, decrementingThread);  
        waitUntilFinish(incrementingThread, decrementingThread);  
  
        out.printf("Counter's value: '%d'.%n", counter.getValue());  
    }  
    
    private static void startThreads(final Thread... threads) {  
        Stream.of(threads).forEach(Thread::start);  
    } 
     
    private static void waitUntilFinish(final Thread... threads) 
	    throws InterruptedException {  
	    
        for (final Thread thread : threads) {  
            thread.join();  
        }    
	}  
	
    private static Runnable createTaskDoingOperationOnCounter(  
            final Counter counter,  
            final IntConsumer operation,  
            final int times) {  
  
        return () -> {  
            counter.lock();  
            try {  
                range(0, times).forEach(operation);  
            } finally {  
                counter.unlock();  
            }        
		};    
	}  
	
    private static final class Counter {  
        private final Lock lock = new ReentrantLock();  
        private int value;  
  
        public void lock() {  
            this.lock.lock();  
            printMessageWithCurrentThreadNameArgument(
		            "Thread %s locked counter.%n");  
        }  
        
        public void increment() {  
            this.value++;  
            printMessageWithCurrentThreadNameArgument(
		            "Thread '%s' incremented counter.%n");  
        }  
        
        public void decrement() {  
            this.value--;  
            printMessageWithCurrentThreadNameArgument(
		            "Thread '%s' decremented counter.%n");  
        }  
        
        public void unlock() {  
            printMessageWithCurrentThreadNameArgument(
		            "Thread '%s' is unlocking counter.%n");  
            this.lock.unlock();  
        }  
        
        public int getValue() {  
            return this.value;  
        }  
        
        private static void printMessageWithCurrentThreadNameArgument(
		        final String message) { 
	         
            out.printf(message, currentThread().getName());  
        }    
	}
}
```
Вывод примерно такой:
```java
Thread incrementer locked counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' incremented counter.
Thread 'incrementer' is unlocking counter.
Thread decrementer locked counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' decremented counter.
Thread 'decrementer' is unlocking counter.
Counter's value: '0'.
```

### `ReentrantLock::ReentrantLock(boolean fairness)`

У `ReentrantLock` есть конструктор, который принимает `boolean` поле `fairness`, которое добавляет в `ReentrantLock` элемент справедливости. Очевидно, что при таком раскладе, поток, который больше всего ждет монитора, получает этот монитор первым.
![[Pasted image 20250826161257.png]]

### `Lock::TryLock()`

`lock()` забирает монитор для потока, если этот монитор свободен. Если же монитор уже залочен другим потоком - `lock` блокирует поток, также работает и `synchronized.

Для того, чтобы в случае, когда монитор уже залочен, не блокировать поток, который претендует на этот монитор, существует метод `tryLock()`, который в случае с уже залоченным монитором возвращает `false`. Также он возвращает `true`  в противном случае ну и очевидно лочит.
![[Screenshot 2025-08-26 at 16.17.25.png]]
Пример:
```java
package org.gerasic;  
  
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
  
import static java.lang.System.out;  
import static java.lang.Thread.currentThread;  
import static java.util.stream.IntStream.range;  
  
public final class TryLockEvenNumberGeneratorMain {  
    public static void main(final String... args) {  
        final EvenNumberGenerator evenNumberGenerator = 
		        new EvenNumberGenerator();  
  
        final Runnable generatingTask = 
		        () -> range(0, 100).forEach(
				        i -> out.println(evenNumberGenerator.generate()));  
  
        final Thread firstThread = new Thread(generatingTask);  
        firstThread.start();  
  
        final Thread secondThread = new Thread(generatingTask);  
        secondThread.start();  
  
        final Thread thirdThread = new Thread(generatingTask);  
        thirdThread.start();  
    }  
    
    public static final class EvenNumberGenerator {  
        private final Lock lock = new ReentrantLock();  
        private int nextEvenValue = 0;  
  
        public int generate() {  
            return this.lock.tryLock()  
                    ? onSuccessAcquireLock()  
                    : onFailAcquireLock();  
        }  
        
        private int onSuccessAcquireLock() {  
            try {  
                return this.nextEvenValue += 2;  
            } finally {  
                this.lock.unlock();  
            }        
		}  
		
        private int onFailAcquireLock() {  
            out.printf("Thread '%s' didn't acquire lock.%n",  
                    currentThread().getName());  
            throw new RuntimeException();  
        }    
	}
}
```
Вывод: через раз выбрасывает `RuntimeException`

### `Lock::TryLock(long time, TimeUnit unit)`

Указывается кол-во времени. Если монитор занят - текущий поток блокируется, и далее есть 3 возможных исхода:
1. Поток интераптнули - тогда он кидает `InterruptedException`
2. Поток смог захватить монитор до истечения времени - `return true`
3. Поток не смог захватить монитор за указанный срок - `return false`
![[Screenshot 2025-08-26 at 16.43.14.png]]

### `Lock::lockInterruptibly()`

Работает точно также как метод `lock()`, но поток, который оказался заблокированным в точке вызова метода `lock()` прервать никак не получится, а поток который оказался залокированным в точке `lockInterruptibly()` прервать возможно. И в случае, если этот поток был прерван - он кидает `InterruptedException`






`ArrayBlockingQueue` — это одна из реализаций интерфейса **BlockingQueue** в Java, которая используется для организации очереди с ограниченной ёмкостью (bounded queue). Она хранит элементы в **массиве фиксированного размера** и поддерживает блокирующие операции вставки и извлечения.
### 1 Характеристики

- Основана на **массиве** (`array`) фиксированной длины.
- Размер задаётся в конструкторе и **не может изменяться**.
- **Потокобезопасная**: использует внутренние **ReentrantLock** и **Condition** для синхронизации.
- Работает по принципу **FIFO** (first-in-first-out) — первый вошёл, первый вышел.

### 2 Поведение при переполнении/опустошении

Методы делятся на четыре группы в зависимости от реакции, если:
- **Очередь заполнена (нельзя вставить элемент)**.
- **Очередь пуста (нельзя взять элемент)**.

| Операция   | Бросает исключение                                | Возвращает спец. значение | Блокируется                  | Таймаут                |
| ---------- | ------------------------------------------------- | ------------------------- | ---------------------------- | ---------------------- |
| Вставка    | `add(e)` → `IllegalStateException`                | `offer(e)` → `false`      | `put(e)` (ждёт освобождения) | `offer(e, time, unit)` |
| Извлечение | `remove()`/`element()` → `NoSuchElementException` | `poll()` → `null`         | `take()` (ждёт элемент)      | `poll(time, unit)`     |

### 3 Конструкторы

```java
ArrayBlockingQueue(int capacity);
ArrayBlockingQueue(int capacity, boolean fair);
ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c);
```

- `capacity` — максимальная вместимость очереди.
- `fair` — политика справедливости:
    - `false` (по умолчанию) — может быть быстрее, но порядок блокировок не гарантируется.
    - `true` — очередность доступа потоков справедлива (FIFO для потоков), но чуть медленнее.

### 4 Пример использования

```java
import java.util.concurrent.*;

public class Example {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);

        // Производитель
        new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("Производитель кладёт: " + i);
                    queue.put(i); // блокируется, если очередь полна
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // Потребитель
        new Thread(() -> {
            try {
                while (true) {
                    Integer value = queue.take(); // блокируется, если очередь пуста
                    System.out.println("Потребитель взял: " + value);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}

```

### 5. Где применяется

- В классической задаче **Producer-Consumer**.
- Для организации **очередей заданий** (tasks) в многопоточных приложениях.
- Когда нужно ограничить использование памяти (bounded queue защищает от переполнения).


Короче это та самая хуйня которую мы уже писали `BoundedBuffer` (очев что внутри реализация другая, но на самом деле они почти идентичны):
```java
package org.gerasic.boundedbuffer;  
  
import java.util.Objects;  
import java.util.concurrent.locks.Condition;  
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
import java.util.stream.Collectors;  
import java.util.stream.Stream;  
  
import static java.lang.System.out;  
  
public final class BoundedBuffer<T> {  
    private final T[] elements;  
    private final Lock lock;  
    private final Condition notFull;  
    private final Condition notEmpty;  
    private int size;  
  
    @SuppressWarnings("unchecked")  
    public BoundedBuffer(final int capacity) {  
        this.elements = (T[]) new Object[capacity];  
        this.lock = new ReentrantLock();  
        this.notFull = lock.newCondition();  
        this.notEmpty = lock.newCondition();  
    }  
    
    public boolean isFull() {  
        lock.lock();  
        try {  
            return this.size == this.elements.length;  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public boolean isEmpty() {  
        this.lock.lock();  
        try {  
            return this.size == 0;  
        } finally {  
            this.lock.unlock();  
        }    
	}  
	
    public void put(final T element) {  
        lock.lock();  
        try {  
            while (isFull()) {  
                notFull.await();  
            }            this.elements[this.size] = element;  
            this.size++;  
            out.printf(
		            "%s was put in buffer. Result buffer: %s%n", 
		            element, 
		            this);  
            this.notEmpty.signal();  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    public T take() {  
        lock.lock();  
        try {  
            while (this.isEmpty()) {  
                notEmpty.await();  
            }            final T result = this.elements[this.size - 1];  
            this.elements[this.size - 1] = null;  
            this.size--;  
            out.printf(
		            "%s was taken from buffer. Result buffer: %s%n", 
		            result, 
		            this);  
            this.notFull.signal();  
            return result;  
        } catch (InterruptedException e) {  
            Thread.currentThread().interrupt();  
            throw new RuntimeException(e);  
        } finally {  
            lock.unlock();  
        }    
	}  
	
    @Override  
    public String toString() {  
        lock.lock();  
        try {  
            return "{" +  
                    Stream.of(this.elements)  
                            .limit(this.size)  
                            .map(Objects::toString)  
                            .collect(Collectors.joining(", ")) +  
                    "}";  
        } finally {  
            lock.unlock();  
        }    
	}
}
```
## 1. **B-Tree (по умолчанию)**

**B-Tree (Balanced Tree, сбалансированное дерево поиска)** — это древовидная структура данных, которая поддерживает:

- поиск по **равенству** (`=`),
- поиск по **диапазону** (`<, <=, >, >=, BETWEEN`),
- частично по **LIKE 'prefix%'`,
- сортировку (`ORDER BY`).

#### Как устроен B-Tree

- Это дерево, где **ключи отсортированы**.
- Каждый узел хранит ссылки на подузлы или на строки таблицы.
- Дерево **сбалансированное** → глубина примерно одинаковая для всех ветвей.

Вот B-Tree в классическом понимании структуры данных:
![[Pasted image 20250831022237.png]]

#### Особенности и ограничения

**Плюсы:**

- Универсальный, работает почти для любых запросов.
- Поддерживает равенство, диапазоны, сортировку.
- Используется «по умолчанию».

**Минусы:**

- Может быть тяжёлым (занимает много места).
- Не подходит для данных без упорядочивания (например, массивы, JSONB).
- Не эффективен для полнотекстового поиска.
- LIKE с шаблоном `'%foo'` не ускорит.

Короче: B-Tree - универсальный индекс, который нужно использовать в **80% случаев**, если только данные не требуют особой структуры (тексты → GIN, большие таблицы → BRIN, геоданные → GiST/SP-GiST).

---

## 2. **Hash**

#### **Как работает:**

- Для каждого значения считается **хэш**, и в таблице индекса хранится пара (хэш → ссылка на строку).
- Нет сортировки → поиск только по точному совпадению.

#### **Где применяется:**

- Для запросов вида `WHERE column = value`.
- Например, поиск по UUID, e-mail, username.

#### **Ограничения:**

- Не поддерживает `<`, `>`, `BETWEEN`.
- В PostgreSQL раньше был проблемный (не поддерживал WAL → не было репликации). Сейчас работает, но **почти всегда B-Tree не хуже**.
- В MySQL отдельного Hash-индекса нет, но **InnoDB** в определённых случаях сам строит **адаптивные хэш-индексы** для часто используемых страниц.

#### **Пример:**

`CREATE INDEX idx_users_email_hash ON users USING hash(email);`

---

## 3. **GIN (Generalized Inverted Index)**

#### **Как работает:**

- Хранит **множество значений → строки**, где они встречаются.
- По сути, это «обратный индекс» (как в поисковых системах).

Обычный индекс (например, B-Tree) хранит **ключ → где находится строка**.

Обратный индекс хранит наоборот:  
**компонента значения → список строк, где она встречается**.

GIN индекс разбивает значения на **компоненты** и строит обратное соответствие:

- Для **массивов**: каждая ячейка массива → список строк, где она встречается.
- Для **JSONB**: ключи/значения внутри JSON → список строк.
- Для **Full-Text Search (TSVECTOR)**: каждое слово → список документов.

Вот типа например:
```
id | tags
---+-----------------
1  | {java, postgres}
2  | {python, ai}
3  | {java, ai}
```

Для `B-tree` индекс по `tags` будет хранить (упрощённо):
```
{java, postgres} → id=1
{python, ai}     → id=2
{java, ai}       → id=3
```

Для **GIN** (обратный индекс) храним поэлементно:
```
java     → {1, 3}
postgres → {1}
python   → {2}
ai       → {2, 3}
```

То есть вместо того, чтобы сравнивать массив целиком, мы знаем, где встречается каждый его элемент.

Это делает GIN очень мощным для случаев, когда данные «составные».

#### **Где применяется:**

- Полнотекстовый поиск (`to_tsvector`, `@@`).
- Поиск по **JSONB** (`WHERE data @> '{"key":"value"}'`).
- Поиск по массивам (`WHERE tags @> '{java}'`).

#### **Ограничения:**

- Медленно обновляется (дорого по INSERT/UPDATE).
- Индекс большой по размеру.
- Хорош только там, где **часто ищем по множествам значений**.

**Пример:**

`CREATE INDEX idx_posts_content_gin  ON posts USING gin(to_tsvector('english', content));`

---

## 4. **GiST (Generalized Search Tree)**

**Как работает:**

- Это «каркас» для разных структур (R-Tree, K-D Tree и др.).
- Поддерживает не только сравнения, но и «близость».

**Где применяется:**

- Геоданные (PostGIS: «найди все точки в радиусе 10 км»).
- Поиск ближайших соседей (`<->` оператор).
- Поиск по диапазонам, пересечениям интервалов.

**Ограничения:**

- Не такой быстрый, как B-Tree или GIN, но универсальный.

**Пример (гео):**

Cтандартная поставка PostgreSQL содержит GiST-классы операторов для **двумерных геометрических типов данных**, которые поддерживают такие операторы
```
<<   &<   &>   >>   <<|   &<|   |&>   |>>   @>   <@   ~=   &&
```
`CREATE INDEX idx_locations_gist  ON locations USING gist(geom);`

GiST также позволяет выполнять **поиск ближайших соседей** (_nearest-neighbor search_), например:

```sql
SELECT * FROM places
ORDER BY location <-> point '(101,456)'
LIMIT 10;
```

---

## 5. **BRIN (Block Range Index)**

**BRIN (Block Range INdex)** — это _сводный индекс_, который хранит не сами значения, а **информацию о диапазонах блоков таблицы**.

- Таблица в PostgreSQL хранится в **страницах по 8 KB**.
- Несколько страниц объединяются в **диапазон блоков** (например, по 128 страниц).
- Для каждого диапазона BRIN хранит **минимум и максимум** значения колонки (или другие агрегаты, если операторный класс поддерживает).

То есть это «индекс на блоки», а не на строки.

#### **Как работает:**

- Хранит **минимум и максимум** для каждого блока (страницы) таблицы.
- Очень лёгкий по размеру (намного меньше B-Tree).
- Но точность грубая: надо потом фильтровать строки.

Пример: таблица с датами вставки заказов (`created_at`).
```python
Block range 1 → min=2021-01-01, max=2021-01-31
Block range 2 → min=2021-02-01, max=2021-02-28
Block range 3 → min=2021-03-01, max=2021-03-31
```

Запрос:
```sql
SELECT * FROM orders WHERE created_at BETWEEN '2021-02-10' AND '2021-02-15';
```

- PostgreSQL смотрит на BRIN-индекс.
- Видит, что только **Block range 2** может содержать такие строки.
- Читает только этот диапазон вместо всей таблицы.

#### **Где применяется:**

BRIN работает хорошо, если данные в колонке **коррелируют с физическим порядком строк**. А также эффективен на очень больших данных.

Примеры:

- **Временные ряды** (дата вставки идёт по возрастанию).
- **ID по автогенерации** (с UR-сортировкой).
- **Геоданные, лог-файлы, телеметрия** (новые данные идут последовательно).

Если данные вставляются «хаотично» (например, случайные UUID), BRIN почти не помогает.

#### **Пример использования:**

```sql
CREATE TABLE logs (
    id bigserial,
    created_at timestamp not null,
    message text
);

-- создаём BRIN по дате
CREATE INDEX logs_created_at_brin
    ON logs USING BRIN (created_at);
```

Запрос:
```sql
SELECT * FROM logs
WHERE created_at BETWEEN '2025-01-01' AND '2025-01-31';
```

Если таблица содержит **миллионы строк**, BRIN быстро отсеет ненужные диапазоны. Полный B-Tree индекс занимал бы гигабайты, а BRIN — **сотни килобайт**.

#### Особенности

**Плюсы:**
- Очень компактный (занимает **в сотни раз меньше места**, чем B-Tree).
- Отличен для **больших таблиц** (миллионы/миллиарды строк).
- Быстрая индексация (создание индекса занимает мало времени).

**Минусы:**

- Менее точный → после выбора диапазона PostgreSQL всё равно делает **recheck** строк.
- Эффективен только при «естественной» корреляции значений и порядка строк.
- Не подходит для поиска по «случайным» значениям (например, UUID или email).

---

#  Когда какой индекс использовать?

| Тип индекса            | Когда использовать                                        |
| ---------------------- | --------------------------------------------------------- |
| **B-Tree**             | почти всегда: `=`, `<`, `>`, `ORDER BY`, `JOIN`           |
| **Hash**               | только `=` (и то редко, в PG почти не нужен)              |
| **GIN**                | JSONB, массивы, полнотекстовый поиск                      |
| **GiST**               | геоданные, поиск по близости                              |
| **BRIN**               | большие таблицы, упорядоченные данные (логи, time-series) |


## Что делает `EXPLAIN` и `EXPLAIN ANALYZE`

1. **EXPLAIN**
    - Показывает **план запроса**, который оптимизатор PostgreSQL построил на основе статистики (распределение значений, количество строк, наличие индексов).
    - Указывает предполагаемую стоимость выполнения: `cost=start..end` и предполагаемое количество строк.
    
2. **EXPLAIN ANALYZE**
    - Запускает запрос реально, выполняет его до конца.
    - Показывает не только план, но и **фактическое время** выполнения каждого узла.
    - Можно сравнить: ожидания оптимизатора vs реальность.

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@test.com';

-- Ответ
Index Scan using users_email_idx on users  (cost=0.29..8.50 rows=1 width=64)
  Index Cond: (email = 'test@test.com'::text)
  Actual time: 0.032..0.033 rows=1 loops=1
```

## Как читать `EXPLAIN ANALYZE`

В плане важны параметры:

- **cost=начало..конец** — оценка стоимости (относительные единицы, не время, для seq scan start = 0, начать читать строку можно сразу, без подготовки (и удовольствия)).
- **rows** — оценка количества строк.
- **actual time=начало..конец** — реальное время выполнения.
- **loops** — сколько раз узел выполнялся.
- **`width`** — средний размер одной строки (в байтах), по статистике таблицы.

Пример:
```sql
Index Scan using users_email_idx on users (cost=0.29..8.50 rows=1 width=64)
  Index Cond: (email = 'test@test.com'::text)
  Actual time: 0.032..0.033 rows=1 loops=1
```
→ Ожидал найти 1 строку, реально нашёл 1, затраты совпали → план хороший.

Если расхождения большие (ожидал 100 строк, а реально 100000) — нужно обновить статистику:

`ANALYZE users;`

## Сканирование таблиц (Table Access Methods)

### 1. **Seq Scan (Sequential Scan)** — последовательное сканирование

- PostgreSQL читает **всю таблицу построчно**.
- Эффективно, если:
    - таблица маленькая,
    - запрос возвращает большой процент строк (например, `WHERE age > 0`),
    - индексы не подходят.
- На больших таблицах — **очень медленно**.

```sql
Seq Scan on users  (cost=0.00..431.00 rows=10000 width=64)
```

---

### 2. **Index Scan**

- Использует **B-Tree индекс** для поиска подходящих строк.
- Работает так:
    - находит значения в индексе,
    - затем идёт в таблицу за самими данными (**lookup по heap**).
- Быстрее `Seq Scan`, если отбирается **малый процент строк**.
- Минус: для каждой строки два обращения — к индексу и к таблице.

```sql
Index Scan using users_email_idx on users (cost=0.29..8.50 rows=1 width=64)
```

---

### 3. **Index Only Scan**

- Если все нужные данные есть в индексе — **таблица не читается вообще**.
- Работает быстрее, чем обычный Index Scan.
- Требует:
    - чтобы индекс покрывал все поля в `SELECT`,
    - чтобы **видимость строк** была закэширована (через `visibility map`).

```sql
CREATE INDEX idx_users_email ON users(email);
EXPLAIN ANALYZE SELECT email FROM users WHERE email = 'test@test.com';
```

---

### 4. **Bitmap Index Scan / Bitmap Heap Scan**

- Используется, если нужно выбрать **много строк** по индексу.
- PostgreSQL сначала собирает «битовую карту» позиций строк (bitmap index scan),  а потом **пакетно считывает** их из таблицы (bitmap heap scan).
- Это лучше, чем `Index Scan`, когда строк очень много.


В `PostgreSQL` индекс - это вспомогательная структура данных, которая позволяет ускорить поиск данных в таблице. Индексы в `pgsql` реализованы разными способами (`B-Tree`, `Hash`, `GiST`, `GIN`, `SP-GiST`, `BRIN`) и выбираются в зависимости от типа данных и характера запросов. 

## **Зачем нужны индексы**

#### 1 Ускорение SELECT-запросов

Без индекса при фильтрации (`WHERE`) или сортировке (`ORDER BY`) таблица сканируется полностью (полный последовательный просмотр всех строк окнами - _sequential scan_). Для больших таблиц это слишком медленно. С индексами PostgreSQL ищет только нужные страницы/строки, что снижает количество I/O операций

#### 2 Поддержка уникальности

При создании индекса с условием UNIQUE PostgreSQL автоматически следит за уникальностью значений в одном или нескольких столбцах. Это удобно для реализации ограничений, например, `email` пользователя должен быть уникальным

**Что это значит на практике?**

В PostgreSQL «уникальность» на уровне столбца (или набора столбцов) действительно реализуется через специальный индекс. Когда мы пишем в определении таблицы что-то вроде

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE
);
```

то PostgreSQL автоматически создаёт для столбца `email` именно _уникальный индекс_ (аналога `CREATE UNIQUE INDEX...`). То есть, с точки зрения движка, проверка «что каждый новый `email` не совпадает ни с одним уже существующим» делается с помощью индекса. За кадром PostgreSQL сделает примерно вот это:

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255)
);

CREATE UNIQUE INDEX users_email_key ON users(email);
ALTER TABLE users
  ADD CONSTRAINT users_email_key UNIQUE USING INDEX users_email_key;
```

**_Note_**: самописанный индекс UNIQUE зачастую дает больше гибкости, например:
```sql
-- 1) Частичная (partial) уникальность: уникально только для не-удалённых записей
CREATE UNIQUE INDEX idx_users_email_active
ON users(email)
WHERE is_deleted = FALSE;

-- 2) Функциональный индекс: уникальность по какому-то выражению
CREATE UNIQUE INDEX idx_lower_email
ON users (LOWER(email));
```
Если бы мы просто писали `email VARCHAR(255) UNIQUE`, PostgreSQL не дал бы вам возможности добавить условие `WHERE is_deleted = FALSE` или индекс по `LOWER(email)`.

#### 3 Ускорение операций `JOIN`

При JOIN-е по колонке например `JOIN ON t1.user_id = t2.user_id` индекс по этой колонке помогает быстрее находить соответствующие строки, особенно если одна из таблиц или обе большие. 

**Что это значит на практике?**

Представьте, что у вас есть список всех клиентов (customers) с их `id` и другими данными. Если вы создаёте индекс по колонке `id`, PostgreSQL строит нечто вроде отсортированного списка «значение → адрес записи», где «адрес записи» (внутренне это может быть номер страницы и смещение внутри страницы) указывает, где лежит строка с этим `id` в самой таблице. По сути, это:

`(клиент_id) → (где в таблице находится строка с этим id)`

Благодаря тому, что весь этот список **отсортирован** (обычно в виде B-дерева), поиск любого конкретного `id` идёт не путём перебора всех элементов, а по схеме «разделяй и властвуй». Если в индексе, скажем, 100 000 значений, СУБД может за ~log₂(100 000) ≈ 17 шагов (а не 100 000) понять, в какой «ветке» находится нужный `id`, затем точечно перейти прямо к нужной записи.

Поэтому когда PostgreSQL выполняет `JOIN`:

1. Берёт очередную строку из таблицы `orders`, допустим `o.customer_id = 123`.
2. Смотрит в индекс на таблицу `customers` по колонке `id`.
3. С помощью «ветвления» B-дерева быстро находит, есть ли `id = 123` и где он лежит.
4. Прямо переходит к этой строке в таблице `customers`, не просматривая все остальные.

Именно этот «прямой переход» через индекс и называется «быстрым поиском соответствующих строк».

**Однако индекс тоже имеет свои расходы:**

- **Дополнительное место на диске**. Чем больше индексов, тем шире расход дискового пространства.
    
- **Замедление операций INSERT/UPDATE/DELETE**. При изменении данных PostgreSQL должен обновить все индексы, затронутые изменившейся строкой. Особенно это заметно при массовых вставках или частых изменениях.

Поэтому важно балансировать: индексы создаются только там, где они реально ускоряют часто выполняемые запросы.

----

## Как выглядит индекс на диске

1. **Отдельная «relation»**  
	В PostgreSQL каждую таблицу, индекс, последовательность и т. д. хранит как отдельную «relation» (аналог обобщённого файла). Когда вы делаете:
	`CREATE INDEX idx_users_email ON users(email);`
	СУБД создаёт некую структуру (физический файл), названную `idx_users_email`, отличную от файла самой таблицы `users`.

2. **Что внутри этой структуры**  
	В случае B-Tree-индекса это почти бинарное дерево (на самом деле B-дерево с ветвлениями), где в вершинах и листьях хранятся:
	- значения из колонки `email` (или их часть, например хэш, если это hash-индекс),
	- и «указатель» на строку таблицы `users` (фактически это сочетается из номера блока и смещения внутри блока).
	То есть, в индексе вы не увидите всех колонок таблицы — только те, которые вы проиндексировали, и ссылку на строку.

Поэтому, когда вы выполняете `SELECT * FROM users WHERE email = 'ivan@example.com'`, PostgreSQL не сканирует весь файл таблицы `users`. Он идёт в файл `idx_users_email`, ищет там значение `'ivan@example.com'` (за время приблизительно O(log N) от числа проиндексированных записей), находит нужный “entry” (ключ + указатель), а затем сразу переходит к строке в основном файле `users` по этому указателю, чтобы выдать вам все остальные столбцы.

## Итог

- **Индекс — это не просто “виртуальное свойство” таблицы**, а реально **отдельный объект (relation) в базе данных**, хранящий только ключевые значения и ссылки на оригинальные строки.

- Благодаря этому PostgreSQL очень быстро находит нужные строки без сканирования всего файла таблицы.

- Но за счёт того, что индекс занимает место и требует поддержки при изменениях, мы добавляем баланс между скоростью чтения (SELECT) и скоростью записи/обновления (INSERT/UPDATE/DELETE).